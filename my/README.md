# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

HOT KEYS

<!-- CTRL-ALT-V - make const;
Ctrl + F (выделяются все слова в текущем файле) потом Alt + Enter, теперь изменить можно все слова сразу
or Ctrl-F2(Fn-F2)
Ctrl+Alt+O - удалить ненужный импорт -->

Курс "React JS - путь самурая 1.0", уроки, практика
https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8

Функциональная компонента - это компонента которая записывается как функция, прнинимает в себя props как аргументы и возвращает JSX разметку.

13. Уроки React JS - git-репозиторий (под видео 2. GIT для новичков)

SCV - sistem control of version

git clone + путь к репозиторию (клонирование репозитория)
git status (статус текущего локального репозитория)
git add + путь к репозиторию (отдача файла пот контроль гита)
git commit - am " coment for fix" (фиксация гитом версии файла)
git push - (отправить все закомиченные изменения в репозитории на сервер)
git pull - (забрать свежие изменения в репозитории на сервере)

gitk --all& (открыть графическую оболочку гита, чтобы позырить все коммиты)
ctrl + insert (копировать в буфер обмена)
shift + insert (вставить из буфера обмена)
git checkout commit-number (переключится на нужный коммит)

В помощь каналу и комрадам, которые в первый раз запустили GIT и при этом файл не комитит
Вбиваем 2 команды со своими данными:
git config --global user.name "Name"

git config --global user.email "e-mail"

14. Уроки React JS - добавление поста на стену (зачатки FLUX-концепции)
15. Уроки React JS - прокидываем callback через props
16. Уроки React JS - onClick, ref, VirtualDOM

value, каждый символ в textarea, мы берем из BLL, в стейте.Делаем мы это через props.Чтобы добавить каждый символ в стейт, т.е.наше value, мы используем обработчик onChange.Программируем наш onChange, чтобы value(символ который мы нажали) передавался в стейт.Делаем это через функцию update, которая должна лежать состейтом в BLL.Прокидываем эту функцию через props в нашу компоненту.В обработчике пишем, вызови update(со значениемvalue(символ)).т.е.то, что мы ввели, через функцию записывается в какой - то массив в стейте.А textarea говорит: ОСейчас кто - то ввел символ и мой value стал тем, что ввели.Быстренько отображаю это, в поле ввода.Получается,сначала поменялся state в BLL, а потом Ui в textarea.Это концепция Flux архитектуры.

35. Уроки, Курс React JS - callback, subscribe, observer

В state мы не можем импортировать функцию renderEntireTree, но мы можем ее туда передать через subscribe,
который вызывается в index.js.После чего, созданная функция renderEntireTree в state переопределяется на ту,
которую мы передали в subscribe.И теперь, когда мы добавляем пост, в state вызывается эта функция renderEntireTree

36. Уроки, Курс React JS - про ООП поверхностно (зачем нам объекты) (на 15.54 минуте обясняется принцип вызова обновления перерисовки)

Комент №1

Про this, как это работает - this нужен для того, например у вас есть функция (действие), которая используется разными объектами и вы пишите внутри нее this.свойство*или*еще_что-то, так вот это действие будет сделано для того объекта в контексте которого вы вызвали этот this, ну как-то так. Например внутри конструктора очень часто пишут this.name = name, this.age = age и соответственно в аргументы приходит имя и возраст - constructor(name, age){...}; и потом у вас есть много объектов с пользователями и им в скобках(аргументах) вы передаете(пишите) имя и возраст например user.('Vasya', 23); все это дело попадает в конструктор и слово this будет иметь ссылку на объект user, т.к. this будет находится в контексте этого объекта, и добавит ему свойства, которые передали и так будет со всеми user1 или user2 и т.д., а конструктор 1. По этому внутри объекта тоже пишут this и оно имеет ссылку на этот объект, т.к. находится в его контексте, , может кому-то поможет.

Комент №2

(3) А вот над подпиской на событие пришлось попотеть, чтобы понять, кто на кого, куда, когда и зачем. Может стоит эти функции назвать иначе, например по аналогии с C#, типа не subscribe, а stateUpdatedEvent (или просто stateUpdated - состояние изменилось)? Типа я - index.js - хочу знать момент, когда данные в файле state.js изменятся, чтобы перерисовать страницу. Для этого я подписываюсь на рассылку (уведомление), о том, что состояние данных изменилось (которое так и называется stateUpdatedEvent). Эта рассылка (уведомление) создается и вызывается в файле state.js., а так как у меня есть доступ к открытым свойствам, методам и событиям файла state.js, значит я могу прикрепить к этому событию (уведомлению) свой callback - свою функцию, которая сработает сразу же, как вызовется это событие (получу уведомление). Как-то так.

И renderEntireTree тоже назвать как-то stateUpdatedEventCallback или короче onStateUpdated, чтобы было понятно, что это callback на событие обновления состояния. И он может быть пустым, если на него никто не подписался (то есть с самого начала он и есть пустой, так как еще никто не подписался). Может кому-то так тоже понятней, а может я еще более путанно написала ))

Кстати, еще в прошлом уроке задумалась о том, что как-то некрасиво выглядит непереопределенная функция renderEntireTree. Не хотелось совать в нее какой-то там alert, а пустым оставлять тоже казалось не комильфо. А тут, как пример, выводим сообщение в консоль, что подписчиков нет. Так принято делать и в реальном мире разработки? Или в будущих уроках мы придем к еще более упрощенной системе?

37. Уроки, Курс React JS - store, state, ООП, рефакторинг

Мы просто передаем store в index.js. И передаем посредством обращения к свойству объекта через точку. Нижнее подчеркивание никак не меняет ситуацию, это просто договорённость разработчиков, что это свойство и его значение трогать не нужно. .bind() позволяет закрепить контекст передаваемой функции (метода). Очень важно, что именно ПЕРЕДАВАЕМОЙ, а не ВЫЗЫВАЕМОЙ. Это очень тонкий момент.

38. Уроки, Курс React JS - dispatch и action

action - это объект, который описывает действие, которое нужно совершить и имеет при себе обязательное свойство "type" с текстовым содержимым обозначающие действие, при необходимости может иметь при себе дополнительные свойства для передачи данных.

"В месте вызова локальной функции onPostChange() через props передаётся store-вский метод dispatch. Здесь же создаётся объект action. В качестве 1-го свойства type определяем значение 'UPDATE-NEW-POST-TEXT', 2-е свойство newText cо значением text. В метод dispatch в качестве входного параметра передаём объект action. Всё это летит в место нахождения метода dispatch, т.е. в store (state.js) и там для отработки логики проверяется условие - чему равно action.type. При этом изменение в UI, которое мы зафиксировали через свойство newText используем для изменения \_state.profilePage.newPostText в BLL..."

https://www.youtube.com/watch?v=UGapN-hrekw

39. - Уроки, Курс React JS - action creator, action type

Создание action - дело опасное. Почему? Потому что нужно создать правильный объект с правильным не только типом, но и ещё с правильным набором свойств, необходимых именно для этого типа экшена (action). Кто определяет правильность этого набора сво-в и самого типа? Бизнес!!!! Store! Стор (хранилище) у нас управляет состоянием и его изменением. Он определяет, КАКОЙ объект должен к нам прийти через dispatch, чтобы мы могли корректно его использовать для трансформации стейта (state)

Поэтому мы инкапсулируем логику создания таких объектов в отдельную функцию - action creator - и отправляем его в store - поближе в бизнес логике!

Ах да, тип экшена... Это строка. Что-то вроде ИМЕНИ экшена. Нельзя опечаться ни в одном символе, иначе наш логика обработки не сможет соотнести этот экшен с нужной веткой обработки. Поэтому выносим названия экшенов (action type) в строковую константу! В строковые константы)) Экшенов же у нас много ;)

S. Принцип единственной ответственности(Single responsibility)
O. Принцип открытости/закрытости (Open-closed)
L. Принцип подстановки Барбары Лисков (Liskov substitution)
I. Принцип разделения интерфейса (Interface segregation)
D. Принцип инверсии зависимостей (Dependency Invertion)

40. - React JS Практика - добавление Сообщения

мы делали ref для текстерии, а здесь сделали при помощи event.target.value? Ты вроде бы говорил, что там без ref пока не обойтись.
NavLink & Route - два независимых элемента (компонента),NavLink - меняет URL, а Route отслеживает изменения URL и подставляет свое значение (данные).

41. - riber) об изменении state, и вызываeт обновленный state для перерисовки. После рефакторинга : каждый reducer получает свой кусоReact JS Практика - reducer (почти redux)

reducer - чистая функция принимающая state & action возвращающая new state. На данный момент action (объект у которого есть как минимум свойство type) -> из Reacta(UI), мы его диспатчим и он изменяет state, после этого store уведомляет подписчиков (subscк state и возвращает новый, если action его меняет, если нет остовляет как и было.

42. - React JS Практика - Redux
      import {combineReducers, legacy_createStore as createStore} from "redux";

43. React JS Практика - container component (контейнерная компонента)

(1) DUMB-Компоненту (призентационная компонента ПК) нужно оставить чистой (без добавления store)
(2) Для того чтобы пункт 1 осуществить, нужно создать компоненту-оболочку или компоненту-контейнер (КК), которая и будет содержать store и все прочее из мира BLL.

В ПК передаем данные из КК функциями колбэками (addPost & onPostChangeContainer).
Функции обработчиков событий в ПК (onAddPost & onPostChange).
onPostChange -> принимает изменения в textarea, присваевает значение изменений в textarea, прокинутой через upNewPostText в props КК, и диспачится в onPostChangeContainer.

(3) Компонента-контейнер содержит в себе DUMB-компоненту (на то она и контейнер) и в JSX разметке рисует её передавая ей все необходимое пропсами.

44. - React JS Практика - Context API
      Создаем объект контекста.
      const MyContext = React.createContext("Hello");
      В скобках указывается значение по-умолчанию, котрое возьмет Consumer, если не получит Provider.

Provider только получает значение. Он ничего никуда не передает.

<!-- (<MyContext.Provider value = "То, что хотите передать">
</MyContext.Provider> -->

Значение попадает в приватное cвойство \_currentValue. Но в JS нет же привата, так что можно в наглую импортировать наш класс туда, куда нам надо и

<!-- <div>MyContext._currentValue</div> но мы так делать не будем.  -->

Поэтому

<!-- <MyContext.Consumer>
    {
        text(Тут лежит то, что схватил провайдер) => <div>text</div>
    }
</MyContext.Consumer>) -->

"TypeError: render is not a function"
На самом деле это не требует новой строки, а требует, чтобы вы отображали один дочерний элемент, который является функцией. Когда вы пишете пробел между Consumer и фигурной скобкой, этот пробел воспринимается, как пустая строка, а за ней идет функция, т е дочерних элементов становится два! [' ', [Function]]. Пишите без пробела <Consumer>{...} или переносите фигурную скобку на новую строку, тк новая строка не создает текстовый узел в виде пустой строки "".

Ответ на "почему именно так" видимо кроется в исторически сложившихся внутри команды правилах по поводу парсинга JSX - так нагляднее ведь в JSX элементе у вас находится вложенный объект, а не кусок объекта конкатенирующий в строке с

45. - React JS практика - connect, mapStateToProps, mapDispatchToProps

46. - React JS практика - копия глубокая vs поверхностная (deep copy vs shallow copy)

Ещё есть один вариант, как можно полностью скопировать объект. Попробуй написать
let newObject = JSON.parse(JSON.stringify(oldObject)) . Тут главная разница в том, что есть такой формат общения в ооп, как JSON(погуглите, там читать минут 5) и у него есть 2 метода. Допустим до вас приходит объект и вы его можете перевести в строку({num: 2, year: 15, boolean: false} ---> в JSON.stringify(Object) мы получим ---> '{"num": 2, "year": 15, "boolean": false}'), а потом перевести обратно в объект JSON.parse(object). Я обычно так делал и мен этого было достаточно, хотя есть и косяки

- при переводе в stringify NaN превращается в null. Вроде это все

Ловите лайфхак: Сначала с помощью JSON.stringify превращаем наш объект в текст, а затем парсим его обратно в объект с помощью JSON.parse.
let a = { name: 'Dimych' };
let b = JSON.parse(JSON.stringify(a));
a == b /// false

Все вложенности также будут скопированы в отдельные объекты и не будут равны (глубокое копирование).

Не копирует методы объекта.

47. - React JS практика - Делаем копию состояния в ProfileReducer

Описание под видео:

connect за кадром подписывается (с помощью store.subscribe) на изменения состояния (state) и перерисовывает только ту компоненту, которой это касается. То есть внутри mapStateToProps мы указываем, какие части стейта нам нужны (фактически: я перерисуюсь только если в стейте изменятся именно эти части).

Поэтому мы не будем делать с вами полную копию ВСЕГО стейта, а только тех объектов, которые будут изменены нашим редьюсером. С одной стороны, это поможет нам экономить память, а с другой - поможет connect-у обновлять только нужные компоненты!!!

Интересный коммент №1

Итог: Детерминированность НЕ обеспечивает идемпотентность и на оборот. Идемпотентность НЕ обеспечивает детерминированность. Мы вполне свободно можем писать грязные функции с любым из этих свойств, и комбинировать их между собой. Это два разных и нечем не связанных свойства функций которые предлагают разные гарантии при реализации.

Интересный коммент №2

Мы имеем исходный state (который хранится в redux: назовем его redux.state) и state - который возвращает наш reducer, назовем его reducer.state. Функция connect проверяет изменился ли redux.state после того, как прошел через reducer... и выясняет, что изменений нет. Почему? Потому что в reducer на вход передается ссылка на redux.state и когда ты меняешь state внутри reducer'a (reducer.state), то на самом деле - ты меняешь все тот же redux.state по ссылке. В итоге, все измменения, внесенные в reducer.state изменяют и redux.state (потому что они ссылаются на один и тот же объект в памяти, см.предидущее видео). И конечно же в результате проверки connect видит, что redux.state и reducer.state - совпадают, а значит ничего не поменялось.

А вот если сделать грамотную копию входящего state, то reducer.state будет работать с отдельным объктом в памяти, изменения которого не затронут redux.state. И при сравнении redux.state и reducer.state - функция connect выяснит, что есть расхождения и надо обнвлять VIRTUAL-DOM -> DOM.

P.S. Я уверен, что там реализована более умная проврка, чем просто redux.state === reducer.state, иначе просто правильная копия (без каких-либо изменений) выдавала бы false.

То есть по итогу переменная под именем stateCopy отдаёт свои данные в объект state и ликвидируется (?)
меня сбивает с толку то, что мы возвращаем из reducer`а именно stateCopy - а не state

если stateCopy - это то, что я обозвал как reducer.state, то сама stateCopy затирается после rerurn (но она же просто ссылка на данные, которые хранятся в памяти).

Мы не можем работать с самим state (я обозвал его, как redux.state) потому что мы не знаем где еще может этот state использоваться. Может от него еще 10 компонент зависит и мы щас ручками state изменим внутри reducer'a, и те компоненты не узнают, что нужный им стейт изменился и им надо отрисоваться заного. Насколько я понимаю, функция connect создает что то вроде подписки на изменение параметров, переданных ей в mapStateToProps, и, чтобы эти redux, сравнивая redux.state и reducer.state - когда видит изменения - вызывает соответсвующие подписки, передавая новые пропсы в connect, а тот передает их компоненте, она видит, что пропсы изменились и перерисовавыется.

А если мы изменим саму переменную state (а это союственно переменная, которая у меня названа redux.state) и потом вернем ее redux'y, то он будет сравнивать redux.state с redux.state в итоге. И, конечно не обнаружит никаких изменений (потому что наш reducer уже МУТИРОВАЛ эту внешнюю переменную)... и ... ну понимаешь что будет дальше? Сам стейт будет изменен, но ни один компонент не получит нужные ему обновленные пропсы, потому, что не вызовутся подписки из redux.

Это лично мое понимание. Я без понятия насколько оно правильное или нет. Потому что спросить не у кого)

Интересный коммент №3

как происходит сравнение при локальном subscribe в функции connect и как реакт понимает, вернулась ли копия state из редюсера или же сам оригинальный state. Получается так:
(1) Мы возвращаем часть state c которой работали из редюсера
(2) Реакт проверяет. Если это ссылка на оригинальный глобальный объект state, то ничего не делается (перерисовки не происходит), т.к. получается, что мы работали с глобальным state и функция редюсера нечистая, так нельзя.
(3) Если же из редюсера возвращается часть объекта state, например state.profilePage.posts, но ссылается уже грубо говоря, на другую ячейку в памяти нежели глобальный оригинальный state.profilePage.posts и при этом есть различия между posts копии и posts оригинала, то перерисовка происходит.
Так ли я понял? Ребят, объясните плз кто до конца врубился.

48. - React JS практика - Делаем копию состояния в DialogReducer

Продолжая тему урока №47 :connact внутри имеет свой метод sibscribe (подписка на изменение state'а), который отдельно следить за изменением state'а в ПК (призентационная компонента) и ее перересовкой. Что значит изменинля state, из-за принципа иммутабельности (в функциональном программировании) мы сам state не можем поменять, это значит появился новый объект появился, новая ссыла.

49. - React JS практика - страница пользователей

Интересный коммент №1

Помогает структурировать все знания создание страницы. Получился такой roadmap по созданию страницы
(1) Route
(2) Папка c jsx/css/container
(3) Link in navbar
(4) Store ветка
(5) Reducer -> initialStore
(6) Верстка (css, map(with key), userContainer, mapStateToProps)
(7) Логика:
7.1. onClick
7.2. mapDispatchToProps
7.3. Reducer
7.3.1. action creator
7.3.2. action type
7.3.3. switch

Интересный коммент №2

Решение через неглубокую копию неверное, т.к если в reducer в initial State есть элемент, то эта копия его просто заменит на свои элементы. Решение Димыча верное, НО после первого прохода нужно возвращать обновленный state и длину users, а у нас
возвращается копия state которая приняла новый state, и пытается добавить еще еще элементы, т.к список не опустел(он у нас постоянный)(не закончился, при запросе к api идет законченный список, и вызывается только один раз при обновлении, поэтому состояние каждый раз сбрасывается и замещается новым списком ). Чтобы это исправить, я добавил проверку длины нового массива при обновлении state, т.е если длина нового массива state больше нуля, то нужно вернуть этот state. и при такой проверке, происходит только один проход, и возвращаются три элемента, без дублирования
(Возможно Димыч специально допустил ошибку, чтобы у нас взорвался мозг, и мы больше думали о том как должен работать state)
case SET_USERS: {
if(state.users.length > 0) {
return state
}
return { ...state,
users:[ ...state.users, ...action.users ],
}
}

Интересный коммент №3 (решил вопрос, но я до сути не дошел)
alpknx
10 месяцев назад
​ @Aleksandra Ryzhkova если пропсы в мап не приходят, то они не отправляются из UsersContainer в Users, значит там не обновляется state в MapStateToProps
попробуйте, поместить один элемент списка в initial state, и замените проверку в reducer на >1, а в Users замените проверку на === 1
Так в инструментах разработчика вы будете сразу видеть что есть в state, что в него приходит, и лучше поймете как он должен изменяться

Два вопроса: не до конца понял в чем проблема с подгрузкой users

50. - React JS практика - REST API (краткая теория)

Хотел добавить немного в теорию по поводу REST API, на одном из собесов мне сказали:
Запрос put - это если мы хотим обновить запись, а если такой записи нет, то создать. При этом отправляются все данные, которые относятся к конкретной записи.
Если же мы хотим обновить только часть данных, то отправляется запрос patch и из данных мы отправляем только идентификатор записи + поля (или поле), которые надо обновить. Если такой записи нет, то ничего не делается.

Используются основные 4 операции: get (нужен чтобы получить данные с сервера, без нагрузки (payload)), post (подразумевает, что мы на сервак что то постим, хотим туда закинуть какието данные, идет большой (payload)), put (обновить данные на сервере, новую картинку закинуть, новые профили заполнить), delete (он как get, нам не надо много данных для того чтобы что то удалить, только id, и там и там id зашивается прямо в url-адрес), patch (CreatReadUpdateDelete)

Для удобного просмотра структуры объекта используем любой on-line JSON viewer (http://jsonviewer.stack.hu/)

52. - React JS практика - Side Effect

side effect - Побочный (внешний\сторонний) эффект - это то, чего не должно быть у чистой функции (pure function). А наша функциональная компонента должна быть именно чистой функцией

a. Чистая функция - детерминирована и не обладает side эффектом
b. Детерминированность - для одних и тех же входных данных один и тот же результат
c. Идемпотентность - при многократном вызове функции состояние будет изменено единожды
d. Имьютабельность - неизменяемость. То есть имьютабельный объект - объект, состояние которого не может быть изменено после создания
e. Side effect - возможность в процессе выполнения вычислений: читать, модифицировать значения глобальных переменных, осуществлять операции ввода-вывода... Например, взаимодействие с БД, с глобальными переменными, HTTP-запросы, случайные числа.

53. - React JS практика - классовый компонент (extends React.Component)

JS ооп язык, что у него есть глобальный Object, у которого метод (а он же объект) constructor, у которого есть prototype. Классовая компонента - объект. Объект создается в самаом Реакте и Реакт при изменении обращается к методу РЕНДЕР данного объекта. Классы нужны для создания однотипных объектов. Для того чтобы можно было реализовывать концепции ООП - инкапсуляция, полиморфизм, наследование.

Чтобы стать программистом, нужно знать принципы ООП как Отче наш. Держите структурированную шпаргалку по объектно-ориентированному программированию.

Главное
Инкапсулируйте все, что может изменяться;
Уделяйте больше внимания интерфейсам, а не их реализациям;
Каждый класс в вашем приложении должен иметь только одно назначение;
Классы — это их поведение и функциональность.
Базовые принципы ООП
Абстракция — отделение концепции от ее экземпляра;
Полиморфизм — реализация задач одной и той же идеи разными способами;
Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
Используйте следующее вместе с наследованием
Делегация — перепоручение задачи от внешнего объекта внутреннему;
Композиция — включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого;
Агрегация — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.
Не повторяйся (Don’t repeat yourself — DRY)
Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте. Это один из принципов читаемого кода.

Принцип единственной обязанности
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Принцип открытости/закрытости
Программные сущности должны быть открыты для расширения, но закрыты для изменений.

Принцип подстановки Барбары Лисков
Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.

Принцип разделения интерфейсов
Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.

Принцип инверсии зависимостей
Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.

Лучше писать методы классов так onSomeMethod = () => {...}, а не onSomeMethod2 () {...}. И объяснялось это тем, что будет меньше проблем с контекстом.

Интересный коммент №1

Не знаю или в будущих уроках ты используешь такую штуку, но лично мне очень круто помогают сэкономить время всякие сниппеты, у меня стоит ES7 React/Redux/GraphQL/React-Native snippets (в Visual code)
. Тот же классовый компонент я просто пишу через английские "ccc", функциональный через "sfc", а потом жму Enter, и мне создаёт весь компонент:

class Users extends Component {

constructor(props) {
super(props);
this.state = { }
}
render() {
return ( );
}
}
export default Users;

Интересный коммент №2

Если вдруг кто-то столкнется с тем, что у него после этого урока рисуется не 10 пользователей, а 20.То это происходит, потому что перерисовка происходит дважды. Происходит это из-за React.StrictMode, которая используется в index.js, и только в dev, если сделать билд продакта, такого не будет.

Смысл в том, что конструктор вызывается дважды, а мы убрали оттуда проверку. Более того, даже если проверку оставить как есть, нарисуется 20 пользователей, потому что вызовы идут один за другим и get запрос успевает уйти до того, как сработает промис, поэтому проверку лучше сделать в самом промисе:

constructor (props) {
super(props);
axios.get('https://social-network.samuraijs.com/api/1.0/users').then(response => {
if(this.props.users.length === 0) this.props.getUsers(response.data.items);
});
}

54. - React JS практика - жизненный цикл, life cycle methods, componentDidMount

(1.) Раз у нас есть класс, значит у нас создался объект, ответственный за конкретную отрисовку конкртной компоненты и именно с ним "общается" React
(2.) Компонент может получить новые пропсы, компонент может быть вмонтирован непосредственно в DOM, компонент может быть из DOM демонтирован папой Реактом, компонент может изменить локальный стейт и обновиться. И обо всём этом как-то должен узнавать объект
(3.) Как? Через методы жизненного цикла.
(4.) Нам пока интересен метод componentDidMount
(5.) Этот метод срабатывает всего один раз, сколько компонент бы не обновлялся в процессе своей жизнедеятельности. По факту вмонтирование в DOM происходит ЕДИНОЖДЫ.
Значит это идеальное место, чтобы сделать инициализационный AJAX запрос, и запросить, например, пользователей! ;)

Интересный коммент №1

Если componentDidMount() вызывается после рендеринга компоненты, то каким образом в готовую компонету попали данные, полученные в результате ajax-запроса на сервер? То есть сначала рендерится компонента, а только потом запрос данных с сервера (по логике - должно быть наоборот: сначала нужно получить данные, а потом на их основании отрендерить компоненту). Или я чего-то недопонял? Или пните, где почитать.

вопрос - супер! Я сам об этом думал и многие задумываются. По сути нам хочется логики такой: сначала всё получили и подготовили, а потом рендерим.

Но нужно об этом не думать! То есть Рендерить конмпоненту React будет всегда как можно быстрее не думая, что ей нужны какие-то данные!

Раньше была иллюзия поведения, Как вы описали и люди и спользовали для запроса componentWillMount (типа будет вмонирована). А раз будет, значит мы сейчас быстро сделаем запрос и типа успеем к вмонтированию?? Нет, не успеем! Запрос AJAX, асинхронный, недетерминированный, фиг знает, когда он завершится... А реакту хочется ренедрить

Краткое резюме: Когда рендерим (а точнее возвращаем JSX), мы должны всегда думать о том, что у нас в текущий render может и не быть данных (пустые массивы\объект-заглушки, null, undefined) и нам нужно в этот момент что-то показать, пока ТАМ, АСИНХРОННО делается запрос!

Интересный коммент №2

логично предположить, что это работает точно так же, как стек обычного JS:

1 console.log(0)
2 setTimeout(() => console.log(1), 0)
3 console.log(2)

выведет тебе 0 -> 2 -> 1

так же и реакт:

1 AJAX запрос
2 вызов render()

запрос отправлен -> рендер вызван. запрос ХЗ когда ответит с срвера (может сеть хреновая вообще и медленно работает), а рендер сделает свое дело сразу (конечно это все очень условно, и не так работает в реале, я просто как упрошенный пример привел)
посморти: https://www.youtube.com/watch?v=vIZs5tH-HGQ&list=PLqKQF2ojwm3l4oPjsB9chrJmlhZ-zOzWT&index=4

Интересный коммент №3

Дима, мы все время гнались за тем, чтобы наши функциональные компоненты были чистыми. Мы старались разделить react и redax - это, фактичкски, одино из условий чистоты. Но! Мы вводим клссы для того, чтобы оправдать делание грязных компонент. Какая разница клас или функция? Они все есть сущностями которые описывают компоненту. Клас также должен быть чистым (сингл респонсибилити или хай кохешен). Почему наша компонента должна заниматься получением данных из сервера? Данные из сервера это же тот самый стейт или стор. Точнее redax - это своеобразная проекция реального стейта из сервера. Логично, что redax должен был бы заниматься получением данных из сервера. Ну и если не redax, то какойто третий игрок. Или я чтото не понял, или Вы потом будете рефакторить и это опять подводной шаг.

55. - React JS практика - pagination (пагинация), постраничный вывод пользователей

56. - React JS практика - Презентационная и Контейнерная компоненты

Ребят, презентационные компоненты должны быть в идеале ВСЕГДА. Это позволяет переиспользовать компоненты, их легко тестировать и понимать зону ответственности компоненты.

Интересный коммент №1

у кого ошибка про внутренности метода onPageChanged, прикол в том, что он теряет this, т.к. this внутри него теперь уже не наша классовая компонента в которой он прописан, а теперь это что то из функциональной компоненты, в которой он вызывается.
Нужно при передаче пропсов в компоненту вместо
onPageChanged={this.onPageChanged}
писать
onPageChanged={this.onPageChanged.bind(this)}
Я не знаю почему у Димыча заработало и без этого, мб это из-за версии реакта

UPD: Вернувшись, понял, почему у Димыча работает. Он метод onPageChanged объявляет синтаксисом стрелочной функции, благодаря чему он сам по себе биндится (ну внутренностей тут не знаю уж). Он об этом способе вроде до этого ролика ещё говорил, может просто когда этот метод писал, решил не проговаривать, ну или же я, делая после просмотра, забыл об этом аспекте)

57. - React JS - пример Preloader, loader-gif, isFetching indication

Ребят, важно дать пользователю обратную связь, какой-то намёк, что, мол, подожди, мы отправили на сервак запрос, всё обрабатывается, но нужно подождать. Именно для этого и показывают всякие крутилки, блокировки кнопок или их прячут и на их месте показывают крутилку) и так далее. Мы с вами всё это будем делать регулярно на всех страницах почти)) А сегодня небольшое введение в проблему!

58. - React JS - mapDispatchToProps лайф-хак

Так вот, если оно так, то можно сократить код, передавая вторым параметром в функцию connect не функцию mapDispatchToProps, а передавая просто объект, состоящий из экшенКриейторов! как-то так))

Интересный коммент №1

вот понятное разьяснение с habr:
" ...если вы передаете в connect вторым аргументом не mapDispatchToProps, а объект с AC, то connect оборачивает ваши AC в функцию-обертку () => store.dispatch(AC) и передаёт в props компонента."

Интересный коммент №2

Мы воспользовались удобной перегрузкой у connect, которая вместо функции принимает обьект - пачку экшен креейторов, и внутри connect уже энкапсулирован вызов dispatch для каждого action creator из переданной пачки! А перегрузка имеется наверное для того чтобы когда надо мы могли заюзать перегрузку с функцией и сами реализовать вызов dispatch, с нужной нам логикой, а в данном случае мы хотим сократить код и энкапсулировпнная реализация нам подходит!

59. - React JS - profile page, ajax, api

Ну что, продолжаем обучаться делать запросы к серверному API. Get-запросы, чтобы получить данные. На этот раз мы будем доставать профиль пользователя: инфа о пользователе + фотка

Action Creator - это функция, которая возвращает объект action. Action - это объект, в котором инкапсулированы все данные для того, чтобы reducer получил этот action и применил изменения в свой state.

60. - React JS - withRouter, props.match.params

URL-адрес, текущий адрес страницы, это тоже ИСТИНА. До этого у нас истиной был BLL (Redux, state), и UI (React) зависел только от него, а сейчас у нас истиной ещё стал и URL-адрес!!!

Чтобы работать с адресом, компоненте нужно получить через props нужные данные. Где их взять в props? С помощью HOC-функции withRouter!

Функция withRouter наподобие функции connect создаёт над отданной ей компонентой ещё одну контейнерную, которая добавит в нашу целевую компоненту через пропсы нужные данные.

В нашем случае нас интересует props.match.params!

Интересный коммент №1

У кого не работает, продублирую путь решения

1 import { useParams } from 'react-router-dom'; - нужно это просто сверху импортировать
2 export function withRouter(Children){
return(props)=>{

            const match  = {params: useParams()};
            return <Children {...props}  match = {match}/>
        }

    } - добавить это перед классовой компонентой
    Остальное делаем как Димыч
    Как я понял, суть решения в том, что мы используем Хук - UseParams, он позволяет достучаться до url
    Но так как нельзя хуки и классы мешать, мы берем и заворачиваем наш хук в функцию, далее из функции, которая как раз совпадает с нерабочим withRouter

Интересный коммент №2

    <!-- Ребята, кто писал проект на react router v6, нужно использовать хуки, а не HOC шаблон. Но по скольку в курсе наша контейнерная компонента ProfileContainer - классовая компонента, то мы не можем использовать хуки в классвовых компонентах. Есть решение из оффициальной документации - создать функцию-обёртку, которая по принципу идентична к withRouter:import {
    useLocation,
    useNavigate,
    useParams,

} from "react-router-dom";

// wrapper to use react router's v6 hooks in class component(to use HOC pattern, like in router v5)
function withRouter(Component) {
function ComponentWithRouterProp(props) {
let location = useLocation();
let navigate = useNavigate();
let params = useParams();
return (<Component
{...props}
router={{ location, navigate, params }}
/>
);
}

    return ComponentWithRouterProp;

}
И теперь, эту функцию нужно использовать👇
export default connect(mapStateToProps, {setUserProfile})(withRouter(ProfileContainer));
Затем, в классе ProfileContainer мы можем получить айдишку пользователя, прописав:
let profileId = this.props.router.params.profileId;
И все, дальше меняем URL запроса, и обновляем данные профиля в зависимости от айди пользователя -->

Интересный комент №3 (свежий вариант)

<!-- Опциональные параметры больше не поддерживаются в react-router-v6, поэтому в документации советуют делать так (погуглите useParams v6.6.1) :
App.js:
<Route path="/profile/">
   <Route path=":userId"  element={<ProfileContainer/>} />
   <Route path="me"        element={<ProfileContainer/> }/>
</Route>
Здесь я сделал отдельный Route по клику на кнопку профайл и захардкодил свой юзер айди (поскольку здесь никакие параметры не передаются), но суть понятна.

В нашем контейнере нам не нужно создавать дополнительную компоненту с помощью withRouter (он больше не поддерживается), но нам нужно импортировать функцию useParams из react-router-dom.
Чтобы всё работало, переделываем классовую компоненту ProfileAPIComponent в функциональную, вместо componentDidMount() пишем:


import {useParams} from 'react-router-dom'
import { useEffect } from 'react';


const ProfileAPIComponent = (props) => {

  const params = useParams()

  // на случай, если айдишник не пришёл
  if (!params.userId) {
    params.userId = вашАйди
  }

  useEffect(() => {
   axios.get(`com/api/1.0/profile/${params.userId}`)
   .then(response=> {props.setProfile(response.data)});
   })

  return (
    <Profile profile= {props.profile} />
  );
}

Ну а connect от react-redux оставляем, как и было, ничего не трогаем.
const ProfileContainer = connect(mapStateToProps, {
    setProfile
}) (ProfileAPIComponent) -->

61. - React JS - cookie, login в теории, auth/me

Ребят, нетленная классика - логин через cookie!!! Понимание этого authentication flow ОБЯЗАТЕЛЬНО!!!

Позже мы с вами рассмотрим и JWT-токены! Ничего сложного, по сути тоже самое, только чуть больше логики написать. Чуть больше!

62. - React JS - практика, follow-unfollow api

Мы с вами реализовали полписку и отписку. Но... Не до конца! Вся логика наша свелась к просто изменению стейта redux при нажатии на кнопки. А нам ведь нужно на сервер запрос отправить.

Сценарий такой:
1 кликаем на кнопку подписаться
2 шлём запрос на сервак
3 сервак говорит: всё ок, подписались
4 после этого только диспатчим экшен в стор

63. - React JS - практика, DAL, axios.create

Друзья, есть 2 истины, которые незыблимые и которые нарушать нельзя: буква S в аббревиатуре SOLID и недублирование кода!

Мы должны всеми правдам и неправдами стремиться к букве S (Single responsibility Principle) и УСТРАНЯТЬ дублирование кода.

Именно про это данный урок:
1 мы выносим в отдельный объект респонсибилити, связанную с взаимодействием с сервером (условный DataAccessLayer) и устраняем дублирование засчёт использования инстанса (экземпляра) axios, который можно создать с помощью axios.create

64. - React JS - практика, button disabled (follow\unfollow)

Нужно ДАТЬ пользователю понять, что JS сейчас в фоне (ajax) отправляет запрос на сервак и ждёт от него овтета. Мол, не нужно нажимать по 100-500 раз кнопку отправить, залогиниться, лайкнуть.. Мы уже, в процессе, подожди...

Но пользователь всё равно будет пытаться "ускорить" этот процесс))

И мы должны ему в этом помешать)

Для этого нужно либо показать крутилку вместо кнопки, либо.. задизеблить саму кнопку: disabled={true}

65. - React JS - урок redux-thunk в деталях (теория)

Ребят, без thunk далеко не уедешь! Что такое thunk?
thunk - это функция, которая как правило делает асинхронную операцию (чаще всего, это ajax-запрос) и несколько диспатчей обычных экшенов!

Помимо ajax-запросов, внутри санки можно запустить другую асинхронщину, например setTimeout, setInterval либо сделать асинзронный запрос к indexedDB...

thunk - это функция бизнес логики (BLL уровень).

thunk - это функция, которую можно задиспатчить. Для этого ВАЖНО, чтобы стор понимал, что делать с санкой-функцией, которую задиспатчили. Для этого мы к стору применяем (applyMidleware) thunk-middleware - промежуточный слой, который будет перехватывать dispatch логику и запсукать санку.

Интересный комент №1

Замыкание, описанное здесь на 20:00 является частным случаем каррирования функций (function currying). Это паттерн, когда функция вместо нескольких параметров принимает только один, и возвращает функцию, ожидающую следующий параметр (и так далее), пока не будут заданы все параметры, после чего уже выполнится тело функции. Вызов такой каррированной функции выглядит как последовательность вызовов функций: doSomething("with this")("and this")("and even this")
Самое полезное свойство каррированных функций в том, что конечный результат является всё ещё функцией, которую предстоит выполнить (т.е. она не выполнена), но её предыдущие параметры ей уже заданы. Это полезно, когда вам нужно передать коллбэк, и у вас уже есть значения части аргументов этого коллбэка, но вызывать его будете не вы, соответственно вам нужно каким-то образом «прилепить» к коллбэку известные аргументы, и тогда где бы этот коллбэк не был вызван, в него уже будут зашиты значения всех каррированных аргументов.

66. - React JS - урок redux-thunk в деталях (практика)

Интересные моменты:

Делали фуллстек - бэк на express (кроме джаваскрипта ж ничё не знаем), бд - mongo, для отображения верстки - handlebars. Деплоил сам на digitalocean, как прокси-сервер использовал nginx.
