# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

HOT KEYS

<!-- CTRL-ALT-V - make const;
Ctrl + F (выделяются все слова в текущем файле) потом Alt + Enter, теперь изменить можно все слова сразу
or Ctrl-F2(Fn-F2)
Ctrl+Alt+O - удалить ненужный импорт
Чтобы не писать постояно console.log() - можно  написать любое выражение которое хочешь вывести в консоль и в конце написать .log , тебе высветит выбрать console.log, выбираешь и у тебя всё автоматом оборачивается в console.log, очень удобно ))
Лайфхак: горячей клавишей Alt+Shift+Enter, можно импортировать все, что нужно файлу
-->

Курс "React JS - путь самурая 1.0", уроки, практика
https://www.youtube.com/playlist?list=PLcvhF2Wqh7DNVy1OCUpG3i5lyxyBWhGZ8

Функциональная компонента - это компонента которая записывается как функция, прнинимает в себя props как аргументы и возвращает JSX разметку.

13. Уроки React JS - git-репозиторий (под видео 2. GIT для новичков)

SCV - sistem control of version

git clone + путь к репозиторию (клонирование репозитория)
git status (статус текущего локального репозитория)
git add + путь к репозиторию (отдача файла пот контроль гита)
git commit - am " coment for fix" (фиксация гитом версии файла)
git push - (отправить все закомиченные изменения в репозитории на сервер)
git pull - (забрать свежие изменения в репозитории на сервере)

gitk --all& (открыть графическую оболочку гита, чтобы позырить все коммиты)
ctrl + insert (копировать в буфер обмена)
shift + insert (вставить из буфера обмена)
git checkout commit-number (переключится на нужный коммит)

В помощь каналу и комрадам, которые в первый раз запустили GIT и при этом файл не комитит
Вбиваем 2 команды со своими данными:
git config --global user.name "Name"

git config --global user.email "e-mail"

14. Уроки React JS - добавление поста на стену (зачатки FLUX-концепции)
15. Уроки React JS - прокидываем callback через props
16. Уроки React JS - onClick, ref, VirtualDOM

value, каждый символ в textarea, мы берем из BLL, в стейте.Делаем мы это через props.Чтобы добавить каждый символ в стейт, т.е.наше value, мы используем обработчик onChange.Программируем наш onChange, чтобы value(символ который мы нажали) передавался в стейт.Делаем это через функцию update, которая должна лежать состейтом в BLL.Прокидываем эту функцию через props в нашу компоненту.В обработчике пишем, вызови update(со значениемvalue(символ)).т.е.то, что мы ввели, через функцию записывается в какой - то массив в стейте.А textarea говорит: ОСейчас кто - то ввел символ и мой value стал тем, что ввели.Быстренько отображаю это, в поле ввода.Получается,сначала поменялся state в BLL, а потом Ui в textarea.Это концепция Flux архитектуры.

35. Уроки, Курс React JS - callback, subscribe, observer

В state мы не можем импортировать функцию renderEntireTree, но мы можем ее туда передать через subscribe,
который вызывается в index.js.После чего, созданная функция renderEntireTree в state переопределяется на ту,
которую мы передали в subscribe.И теперь, когда мы добавляем пост, в state вызывается эта функция renderEntireTree

36. Уроки, Курс React JS - про ООП поверхностно (зачем нам объекты) (на 15.54 минуте обясняется принцип вызова обновления перерисовки)

Комент №1

Про this, как это работает - this нужен для того, например у вас есть функция (действие), которая используется разными объектами и вы пишите внутри нее this.свойство*или*еще_что-то, так вот это действие будет сделано для того объекта в контексте которого вы вызвали этот this, ну как-то так. Например внутри конструктора очень часто пишут this.name = name, this.age = age и соответственно в аргументы приходит имя и возраст - constructor(name, age){...}; и потом у вас есть много объектов с пользователями и им в скобках(аргументах) вы передаете(пишите) имя и возраст например user.('Vasya', 23); все это дело попадает в конструктор и слово this будет иметь ссылку на объект user, т.к. this будет находится в контексте этого объекта, и добавит ему свойства, которые передали и так будет со всеми user1 или user2 и т.д., а конструктор 1. По этому внутри объекта тоже пишут this и оно имеет ссылку на этот объект, т.к. находится в его контексте, , может кому-то поможет.

Комент №2

(3) А вот над подпиской на событие пришлось попотеть, чтобы понять, кто на кого, куда, когда и зачем. Может стоит эти функции назвать иначе, например по аналогии с C#, типа не subscribe, а stateUpdatedEvent (или просто stateUpdated - состояние изменилось)? Типа я - index.js - хочу знать момент, когда данные в файле state.js изменятся, чтобы перерисовать страницу. Для этого я подписываюсь на рассылку (уведомление), о том, что состояние данных изменилось (которое так и называется stateUpdatedEvent). Эта рассылка (уведомление) создается и вызывается в файле state.js., а так как у меня есть доступ к открытым свойствам, методам и событиям файла state.js, значит я могу прикрепить к этому событию (уведомлению) свой callback - свою функцию, которая сработает сразу же, как вызовется это событие (получу уведомление). Как-то так.

И renderEntireTree тоже назвать как-то stateUpdatedEventCallback или короче onStateUpdated, чтобы было понятно, что это callback на событие обновления состояния. И он может быть пустым, если на него никто не подписался (то есть с самого начала он и есть пустой, так как еще никто не подписался). Может кому-то так тоже понятней, а может я еще более путанно написала ))

Кстати, еще в прошлом уроке задумалась о том, что как-то некрасиво выглядит непереопределенная функция renderEntireTree. Не хотелось совать в нее какой-то там alert, а пустым оставлять тоже казалось не комильфо. А тут, как пример, выводим сообщение в консоль, что подписчиков нет. Так принято делать и в реальном мире разработки? Или в будущих уроках мы придем к еще более упрощенной системе?

37. Уроки, Курс React JS - store, state, ООП, рефакторинг

Мы просто передаем store в index.js. И передаем посредством обращения к свойству объекта через точку. Нижнее подчеркивание никак не меняет ситуацию, это просто договорённость разработчиков, что это свойство и его значение трогать не нужно. .bind() позволяет закрепить контекст передаваемой функции (метода). Очень важно, что именно ПЕРЕДАВАЕМОЙ, а не ВЫЗЫВАЕМОЙ. Это очень тонкий момент (19 минута видио).

38. Уроки, Курс React JS - dispatch и action

action - это объект, который описывает действие, которое нужно совершить и имеет при себе обязательное свойство "type" с текстовым содержимым обозначающие действие, при необходимости может иметь при себе дополнительные свойства для передачи данных.

"В месте вызова локальной функции onPostChange() через props передаётся store-вский метод dispatch. Здесь же создаётся объект action. В качестве 1-го свойства type определяем значение 'UPDATE-NEW-POST-TEXT', 2-е свойство newText cо значением text. В метод dispatch в качестве входного параметра передаём объект action. Всё это летит в место нахождения метода dispatch, т.е. в store (state.js) и там для отработки логики проверяется условие - чему равно action.type. При этом изменение в UI, которое мы зафиксировали через свойство newText используем для изменения \_state.profilePage.newPostText в BLL..."

https://www.youtube.com/watch?v=UGapN-hrekw

39. - Уроки, Курс React JS - action creator, action type

Создание action - дело опасное. Почему? Потому что нужно создать правильный объект с правильным не только типом, но и ещё с правильным набором свойств, необходимых именно для этого типа экшена (action). Кто определяет правильность этого набора сво-в и самого типа? Бизнес!!!! Store! Стор (хранилище) у нас управляет состоянием и его изменением. Он определяет, КАКОЙ объект должен к нам прийти через dispatch, чтобы мы могли корректно его использовать для трансформации стейта (state)

Поэтому мы инкапсулируем логику создания таких объектов в отдельную функцию - action creator - и отправляем его в store - поближе в бизнес логике!

Ах да, тип экшена... Это строка. Что-то вроде ИМЕНИ экшена. Нельзя опечаться ни в одном символе, иначе наш логика обработки не сможет соотнести этот экшен с нужной веткой обработки. Поэтому выносим названия экшенов (action type) в строковую константу! В строковые константы)) Экшенов же у нас много ;)

S. Принцип единственной ответственности(Single responsibility)
O. Принцип открытости/закрытости (Open-closed)
L. Принцип подстановки Барбары Лисков (Liskov substitution)
I. Принцип разделения интерфейса (Interface segregation)
D. Принцип инверсии зависимостей (Dependency Invertion)

40. - React JS Практика - добавление Сообщения

мы делали ref для текстерии, а здесь сделали при помощи event.target.value? Ты вроде бы говорил, что там без ref пока не обойтись.
NavLink & Route - два независимых элемента (компонента),NavLink - меняет URL, а Route отслеживает изменения URL и подставляет свое значение (данные).

41. - riber) об изменении state, и вызываeт обновленный state для перерисовки. После рефакторинга : каждый reducer получает свой кусоReact JS Практика - reducer (почти redux)

reducer - чистая функция принимающая state & action возвращающая new state. На данный момент action (объект у которого есть как минимум свойство type) -> из Reacta(UI), мы его диспатчим и он изменяет state, после этого store уведомляет подписчиков (subscк state и возвращает новый, если action его меняет, если нет остовляет как и было.

42. - React JS Практика - Redux
      import {combineReducers, legacy_createStore as createStore} from "redux";

43. React JS Практика - container component (контейнерная компонента)

(1) DUMB-Компоненту (призентационная компонента ПК) нужно оставить чистой (без добавления store)
(2) Для того чтобы пункт 1 осуществить, нужно создать компоненту-оболочку или компоненту-контейнер (КК), которая и будет содержать store и все прочее из мира BLL.

В ПК передаем данные из КК функциями колбэками (addPost & onPostChangeContainer).
Функции обработчиков событий в ПК (onAddPost & onPostChange).
onPostChange -> принимает изменения в textarea, присваевает значение изменений в textarea, прокинутой через upNewPostText в props КК, и диспачится в onPostChangeContainer.

(3) Компонента-контейнер содержит в себе DUMB-компоненту (на то она и контейнер) и в JSX разметке рисует её передавая ей все необходимое пропсами.

44. - React JS Практика - Context API
      Создаем объект контекста.
      const MyContext = React.createContext("Hello");
      В скобках указывается значение по-умолчанию, котрое возьмет Consumer, если не получит Provider.

Provider только получает значение. Он ничего никуда не передает.

<!-- (<MyContext.Provider value = "То, что хотите передать">
</MyContext.Provider> -->

Значение попадает в приватное cвойство \_currentValue. Но в JS нет же привата, так что можно в наглую импортировать наш класс туда, куда нам надо и

<!-- <div>MyContext._currentValue</div> но мы так делать не будем.  -->

Поэтому

<!-- <MyContext.Consumer>
    {
        text(Тут лежит то, что схватил провайдер) => <div>text</div>
    }
</MyContext.Consumer>) -->

"TypeError: render is not a function"
На самом деле это не требует новой строки, а требует, чтобы вы отображали один дочерний элемент, который является функцией. Когда вы пишете пробел между Consumer и фигурной скобкой, этот пробел воспринимается, как пустая строка, а за ней идет функция, т е дочерних элементов становится два! [' ', [Function]]. Пишите без пробела <Consumer>{...} или переносите фигурную скобку на новую строку, тк новая строка не создает текстовый узел в виде пустой строки "".

Ответ на "почему именно так" видимо кроется в исторически сложившихся внутри команды правилах по поводу парсинга JSX - так нагляднее ведь в JSX элементе у вас находится вложенный объект, а не кусок объекта конкатенирующий в строке с

45. - React JS практика - connect, mapStateToProps, mapDispatchToProps

46. - React JS практика - копия глубокая vs поверхностная (deep copy vs shallow copy)

Ещё есть один вариант, как можно полностью скопировать объект. Попробуй написать
let newObject = JSON.parse(JSON.stringify(oldObject)) . Тут главная разница в том, что есть такой формат общения в ооп, как JSON(погуглите, там читать минут 5) и у него есть 2 метода. Допустим до вас приходит объект и вы его можете перевести в строку({num: 2, year: 15, boolean: false} ---> в JSON.stringify(Object) мы получим ---> '{"num": 2, "year": 15, "boolean": false}'), а потом перевести обратно в объект JSON.parse(object). Я обычно так делал и мен этого было достаточно, хотя есть и косяки

- при переводе в stringify NaN превращается в null. Вроде это все

Ловите лайфхак: Сначала с помощью JSON.stringify превращаем наш объект в текст, а затем парсим его обратно в объект с помощью JSON.parse.
let a = { name: 'Dimych' };
let b = JSON.parse(JSON.stringify(a));
a == b /// false

Все вложенности также будут скопированы в отдельные объекты и не будут равны (глубокое копирование).

Не копирует методы объекта.

47. - React JS практика - Делаем копию состояния в ProfileReducer

Описание под видео:

connect за кадром подписывается (с помощью store.subscribe) на изменения состояния (state) и перерисовывает только ту компоненту, которой это касается. То есть внутри mapStateToProps мы указываем, какие части стейта нам нужны (фактически: я перерисуюсь только если в стейте изменятся именно эти части).

Поэтому мы не будем делать с вами полную копию ВСЕГО стейта, а только тех объектов, которые будут изменены нашим редьюсером. С одной стороны, это поможет нам экономить память, а с другой - поможет connect-у обновлять только нужные компоненты!!!

Интересный коммент №1

Итог: Детерминированность НЕ обеспечивает идемпотентность и на оборот. Идемпотентность НЕ обеспечивает детерминированность. Мы вполне свободно можем писать грязные функции с любым из этих свойств, и комбинировать их между собой. Это два разных и нечем не связанных свойства функций которые предлагают разные гарантии при реализации.

Интересный коммент №2

Мы имеем исходный state (который хранится в redux: назовем его redux.state) и state - который возвращает наш reducer, назовем его reducer.state. Функция connect проверяет изменился ли redux.state после того, как прошел через reducer... и выясняет, что изменений нет. Почему? Потому что в reducer на вход передается ссылка на redux.state и когда ты меняешь state внутри reducer'a (reducer.state), то на самом деле - ты меняешь все тот же redux.state по ссылке. В итоге, все измменения, внесенные в reducer.state изменяют и redux.state (потому что они ссылаются на один и тот же объект в памяти, см.предидущее видео). И конечно же в результате проверки connect видит, что redux.state и reducer.state - совпадают, а значит ничего не поменялось.

А вот если сделать грамотную копию входящего state, то reducer.state будет работать с отдельным объктом в памяти, изменения которого не затронут redux.state. И при сравнении redux.state и reducer.state - функция connect выяснит, что есть расхождения и надо обнвлять VIRTUAL-DOM -> DOM.

P.S. Я уверен, что там реализована более умная проврка, чем просто redux.state === reducer.state, иначе просто правильная копия (без каких-либо изменений) выдавала бы false.

То есть по итогу переменная под именем stateCopy отдаёт свои данные в объект state и ликвидируется (?)
меня сбивает с толку то, что мы возвращаем из reducer`а именно stateCopy - а не state

если stateCopy - это то, что я обозвал как reducer.state, то сама stateCopy затирается после rerurn (но она же просто ссылка на данные, которые хранятся в памяти).

Мы не можем работать с самим state (я обозвал его, как redux.state) потому что мы не знаем где еще может этот state использоваться. Может от него еще 10 компонент зависит и мы щас ручками state изменим внутри reducer'a, и те компоненты не узнают, что нужный им стейт изменился и им надо отрисоваться заного. Насколько я понимаю, функция connect создает что то вроде подписки на изменение параметров, переданных ей в mapStateToProps, и, чтобы эти redux, сравнивая redux.state и reducer.state - когда видит изменения - вызывает соответсвующие подписки, передавая новые пропсы в connect, а тот передает их компоненте, она видит, что пропсы изменились и перерисовавыется.

А если мы изменим саму переменную state (а это союственно переменная, которая у меня названа redux.state) и потом вернем ее redux'y, то он будет сравнивать redux.state с redux.state в итоге. И, конечно не обнаружит никаких изменений (потому что наш reducer уже МУТИРОВАЛ эту внешнюю переменную)... и ... ну понимаешь что будет дальше? Сам стейт будет изменен, но ни один компонент не получит нужные ему обновленные пропсы, потому, что не вызовутся подписки из redux.

Это лично мое понимание. Я без понятия насколько оно правильное или нет. Потому что спросить не у кого)

Интересный коммент №3

как происходит сравнение при локальном subscribe в функции connect и как реакт понимает, вернулась ли копия state из редюсера или же сам оригинальный state. Получается так:
(1) Мы возвращаем часть state c которой работали из редюсера
(2) Реакт проверяет. Если это ссылка на оригинальный глобальный объект state, то ничего не делается (перерисовки не происходит), т.к. получается, что мы работали с глобальным state и функция редюсера нечистая, так нельзя.
(3) Если же из редюсера возвращается часть объекта state, например state.profilePage.posts, но ссылается уже грубо говоря, на другую ячейку в памяти нежели глобальный оригинальный state.profilePage.posts и при этом есть различия между posts копии и posts оригинала, то перерисовка происходит.
Так ли я понял? Ребят, объясните плз кто до конца врубился.

48. - React JS практика - Делаем копию состояния в DialogReducer

Продолжая тему урока №47 :connact внутри имеет свой метод sibscribe (подписка на изменение state'а), который отдельно следить за изменением state'а в ПК (призентационная компонента) и ее перересовкой. Что значит изменинля state, из-за принципа иммутабельности (в функциональном программировании) мы сам state не можем поменять, это значит появился новый объект появился, новая ссыла.

49. - React JS практика - страница пользователей

Интересный коммент №1

Помогает структурировать все знания создание страницы. Получился такой roadmap по созданию страницы
(1) Route
(2) Папка c jsx/css/container
(3) Link in navbar
(4) Store ветка
(5) Reducer -> initialStore
(6) Верстка (css, map(with key), userContainer, mapStateToProps)
(7) Логика:
7.1. onClick
7.2. mapDispatchToProps
7.3. Reducer
7.3.1. action creator
7.3.2. action type
7.3.3. switch

Интересный коммент №2

Решение через неглубокую копию неверное, т.к если в reducer в initial State есть элемент, то эта копия его просто заменит на свои элементы. Решение Димыча верное, НО после первого прохода нужно возвращать обновленный state и длину users, а у нас
возвращается копия state которая приняла новый state, и пытается добавить еще еще элементы, т.к список не опустел(он у нас постоянный)(не закончился, при запросе к api идет законченный список, и вызывается только один раз при обновлении, поэтому состояние каждый раз сбрасывается и замещается новым списком ). Чтобы это исправить, я добавил проверку длины нового массива при обновлении state, т.е если длина нового массива state больше нуля, то нужно вернуть этот state. и при такой проверке, происходит только один проход, и возвращаются три элемента, без дублирования
(Возможно Димыч специально допустил ошибку, чтобы у нас взорвался мозг, и мы больше думали о том как должен работать state)
case SET_USERS: {
if(state.users.length > 0) {
return state
}
return { ...state,
users:[ ...state.users, ...action.users ],
}
}

Интересный коммент №3 (решил вопрос, но я до сути не дошел)
alpknx
10 месяцев назад
​ @Aleksandra Ryzhkova если пропсы в мап не приходят, то они не отправляются из UsersContainer в Users, значит там не обновляется state в MapStateToProps
попробуйте, поместить один элемент списка в initial state, и замените проверку в reducer на >1, а в Users замените проверку на === 1
Так в инструментах разработчика вы будете сразу видеть что есть в state, что в него приходит, и лучше поймете как он должен изменяться

Два вопроса: не до конца понял в чем проблема с подгрузкой users

50. - React JS практика - REST API (краткая теория)

Хотел добавить немного в теорию по поводу REST API, на одном из собесов мне сказали:
Запрос put - это если мы хотим обновить запись, а если такой записи нет, то создать. При этом отправляются все данные, которые относятся к конкретной записи.
Если же мы хотим обновить только часть данных, то отправляется запрос patch и из данных мы отправляем только идентификатор записи + поля (или поле), которые надо обновить. Если такой записи нет, то ничего не делается.

Используются основные 4 операции: get (нужен чтобы получить данные с сервера, без нагрузки (payload)), post (подразумевает, что мы на сервак что то постим, хотим туда закинуть какието данные, идет большой (payload)), put (обновить данные на сервере, новую картинку закинуть, новые профили заполнить), delete (он как get, нам не надо много данных для того чтобы что то удалить, только id, и там и там id зашивается прямо в url-адрес), patch (CreatReadUpdateDelete)

Для удобного просмотра структуры объекта используем любой on-line JSON viewer (http://jsonviewer.stack.hu/)

52. - React JS практика - Side Effect

side effect - Побочный (внешний\сторонний) эффект - это то, чего не должно быть у чистой функции (pure function). А наша функциональная компонента должна быть именно чистой функцией

a. Чистая функция - детерминирована и не обладает side эффектом
b. Детерминированность - для одних и тех же входных данных один и тот же результат
c. Идемпотентность - при многократном вызове функции состояние будет изменено единожды
d. Имьютабельность - неизменяемость. То есть имьютабельный объект - объект, состояние которого не может быть изменено после создания
e. Side effect - возможность в процессе выполнения вычислений: читать, модифицировать значения глобальных переменных, осуществлять операции ввода-вывода... Например, взаимодействие с БД, с глобальными переменными, HTTP-запросы, случайные числа.

53. - React JS практика - классовый компонент (extends React.Component)

JS ооп язык, что у него есть глобальный Object, у которого метод (а он же объект) constructor, у которого есть prototype. Классовая компонента - объект. Объект создается в самаом Реакте и Реакт при изменении обращается к методу РЕНДЕР данного объекта. Классы нужны для создания однотипных объектов. Для того чтобы можно было реализовывать концепции ООП - инкапсуляция, полиморфизм, наследование.

Чтобы стать программистом, нужно знать принципы ООП как Отче наш. Держите структурированную шпаргалку по объектно-ориентированному программированию.

Главное
Инкапсулируйте все, что может изменяться;
Уделяйте больше внимания интерфейсам, а не их реализациям;
Каждый класс в вашем приложении должен иметь только одно назначение;
Классы — это их поведение и функциональность.
Базовые принципы ООП
Абстракция — отделение концепции от ее экземпляра;
Полиморфизм — реализация задач одной и той же идеи разными способами;
Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
Используйте следующее вместе с наследованием
Делегация — перепоручение задачи от внешнего объекта внутреннему;
Композиция — включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого;
Агрегация — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.
Не повторяйся (Don’t repeat yourself — DRY)
Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте. Это один из принципов читаемого кода.

Принцип единственной обязанности
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Принцип открытости/закрытости
Программные сущности должны быть открыты для расширения, но закрыты для изменений.

Принцип подстановки Барбары Лисков
Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.

Принцип разделения интерфейсов
Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.

Принцип инверсии зависимостей
Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.

Лучше писать методы классов так onSomeMethod = () => {...}, а не onSomeMethod2 () {...}. И объяснялось это тем, что будет меньше проблем с контекстом.

Интересный коммент №1

Не знаю или в будущих уроках ты используешь такую штуку, но лично мне очень круто помогают сэкономить время всякие сниппеты, у меня стоит ES7 React/Redux/GraphQL/React-Native snippets (в Visual code)
. Тот же классовый компонент я просто пишу через английские "ccc", функциональный через "sfc", а потом жму Enter, и мне создаёт весь компонент:

class Users extends Component {

constructor(props) {
super(props);
this.state = { }
}
render() {
return ( );
}
}
export default Users;

Интересный коммент №2

Если вдруг кто-то столкнется с тем, что у него после этого урока рисуется не 10 пользователей, а 20.То это происходит, потому что перерисовка происходит дважды. Происходит это из-за React.StrictMode, которая используется в index.js, и только в dev, если сделать билд продакта, такого не будет.

Смысл в том, что конструктор вызывается дважды, а мы убрали оттуда проверку. Более того, даже если проверку оставить как есть, нарисуется 20 пользователей, потому что вызовы идут один за другим и get запрос успевает уйти до того, как сработает промис, поэтому проверку лучше сделать в самом промисе:

constructor (props) {
super(props);
axios.get('https://social-network.samuraijs.com/api/1.0/users').then(response => {
if(this.props.users.length === 0) this.props.getUsers(response.data.items);
});
}

54. - React JS практика - жизненный цикл, life cycle methods, componentDidMount

(1.) Раз у нас есть класс, значит у нас создался объект, ответственный за конкретную отрисовку конкртной компоненты и именно с ним "общается" React
(2.) Компонент может получить новые пропсы, компонент может быть вмонтирован непосредственно в DOM, компонент может быть из DOM демонтирован папой Реактом, компонент может изменить локальный стейт и обновиться. И обо всём этом как-то должен узнавать объект
(3.) Как? Через методы жизненного цикла.
(4.) Нам пока интересен метод componentDidMount
(5.) Этот метод срабатывает всего один раз, сколько компонент бы не обновлялся в процессе своей жизнедеятельности. По факту вмонтирование в DOM происходит ЕДИНОЖДЫ.
Значит это идеальное место, чтобы сделать инициализационный AJAX запрос, и запросить, например, пользователей! ;)

Интересный коммент №1

Если componentDidMount() вызывается после рендеринга компоненты, то каким образом в готовую компонету попали данные, полученные в результате ajax-запроса на сервер? То есть сначала рендерится компонента, а только потом запрос данных с сервера (по логике - должно быть наоборот: сначала нужно получить данные, а потом на их основании отрендерить компоненту). Или я чего-то недопонял? Или пните, где почитать.

вопрос - супер! Я сам об этом думал и многие задумываются. По сути нам хочется логики такой: сначала всё получили и подготовили, а потом рендерим.

Но нужно об этом не думать! То есть Рендерить конмпоненту React будет всегда как можно быстрее не думая, что ей нужны какие-то данные!

Раньше была иллюзия поведения, Как вы описали и люди и спользовали для запроса componentWillMount (типа будет вмонирована). А раз будет, значит мы сейчас быстро сделаем запрос и типа успеем к вмонтированию?? Нет, не успеем! Запрос AJAX, асинхронный, недетерминированный, фиг знает, когда он завершится... А реакту хочется ренедрить

Краткое резюме: Когда рендерим (а точнее возвращаем JSX), мы должны всегда думать о том, что у нас в текущий render может и не быть данных (пустые массивы\объект-заглушки, null, undefined) и нам нужно в этот момент что-то показать, пока ТАМ, АСИНХРОННО делается запрос!

Интересный коммент №2

логично предположить, что это работает точно так же, как стек обычного JS:

1 console.log(0)
2 setTimeout(() => console.log(1), 0)
3 console.log(2)

выведет тебе 0 -> 2 -> 1

так же и реакт:

1 AJAX запрос
2 вызов render()

запрос отправлен -> рендер вызван. запрос ХЗ когда ответит с срвера (может сеть хреновая вообще и медленно работает), а рендер сделает свое дело сразу (конечно это все очень условно, и не так работает в реале, я просто как упрошенный пример привел)
посморти: https://www.youtube.com/watch?v=vIZs5tH-HGQ&list=PLqKQF2ojwm3l4oPjsB9chrJmlhZ-zOzWT&index=4

Интересный коммент №3

Дима, мы все время гнались за тем, чтобы наши функциональные компоненты были чистыми. Мы старались разделить react и redax - это, фактичкски, одино из условий чистоты. Но! Мы вводим клссы для того, чтобы оправдать делание грязных компонент. Какая разница клас или функция? Они все есть сущностями которые описывают компоненту. Клас также должен быть чистым (сингл респонсибилити или хай кохешен). Почему наша компонента должна заниматься получением данных из сервера? Данные из сервера это же тот самый стейт или стор. Точнее redax - это своеобразная проекция реального стейта из сервера. Логично, что redax должен был бы заниматься получением данных из сервера. Ну и если не redax, то какойто третий игрок. Или я чтото не понял, или Вы потом будете рефакторить и это опять подводной шаг.

55. - React JS практика - pagination (пагинация), постраничный вывод пользователей

56. - React JS практика - Презентационная и Контейнерная компоненты

Ребят, презентационные компоненты должны быть в идеале ВСЕГДА. Это позволяет переиспользовать компоненты, их легко тестировать и понимать зону ответственности компоненты.

Интересный коммент №1

у кого ошибка про внутренности метода onPageChanged, прикол в том, что он теряет this, т.к. this внутри него теперь уже не наша классовая компонента в которой он прописан, а теперь это что то из функциональной компоненты, в которой он вызывается.
Нужно при передаче пропсов в компоненту вместо
onPageChanged={this.onPageChanged}
писать
onPageChanged={this.onPageChanged.bind(this)}
Я не знаю почему у Димыча заработало и без этого, мб это из-за версии реакта

UPD: Вернувшись, понял, почему у Димыча работает. Он метод onPageChanged объявляет синтаксисом стрелочной функции, благодаря чему он сам по себе биндится (ну внутренностей тут не знаю уж). Он об этом способе вроде до этого ролика ещё говорил, может просто когда этот метод писал, решил не проговаривать, ну или же я, делая после просмотра, забыл об этом аспекте)

57. - React JS - пример Preloader, loader-gif, isFetching indication

Ребят, важно дать пользователю обратную связь, какой-то намёк, что, мол, подожди, мы отправили на сервак запрос, всё обрабатывается, но нужно подождать. Именно для этого и показывают всякие крутилки, блокировки кнопок или их прячут и на их месте показывают крутилку) и так далее. Мы с вами всё это будем делать регулярно на всех страницах почти)) А сегодня небольшое введение в проблему!

58. - React JS - mapDispatchToProps лайф-хак

Так вот, если оно так, то можно сократить код, передавая вторым параметром в функцию connect не функцию mapDispatchToProps, а передавая просто объект, состоящий из экшенКриейторов! как-то так))

Интересный коммент №1

вот понятное разьяснение с habr:
" ...если вы передаете в connect вторым аргументом не mapDispatchToProps, а объект с AC, то connect оборачивает ваши AC в функцию-обертку () => store.dispatch(AC) и передаёт в props компонента."

Интересный коммент №2

Мы воспользовались удобной перегрузкой у connect, которая вместо функции принимает обьект - пачку экшен креейторов, и внутри connect уже энкапсулирован вызов dispatch для каждого action creator из переданной пачки! А перегрузка имеется наверное для того чтобы когда надо мы могли заюзать перегрузку с функцией и сами реализовать вызов dispatch, с нужной нам логикой, а в данном случае мы хотим сократить код и энкапсулировпнная реализация нам подходит!

59. - React JS - profile page, ajax, api

Ну что, продолжаем обучаться делать запросы к серверному API. Get-запросы, чтобы получить данные. На этот раз мы будем доставать профиль пользователя: инфа о пользователе + фотка

Action Creator - это функция, которая возвращает объект action. Action - это объект, в котором инкапсулированы все данные для того, чтобы reducer получил этот action и применил изменения в свой state.

60. - React JS - withRouter, props.match.params

URL-адрес, текущий адрес страницы, это тоже ИСТИНА. До этого у нас истиной был BLL (Redux, state), и UI (React) зависел только от него, а сейчас у нас истиной ещё стал и URL-адрес!!!

Чтобы работать с адресом, компоненте нужно получить через props нужные данные. Где их взять в props? С помощью HOC-функции withRouter!

Функция withRouter наподобие функции connect создаёт над отданной ей компонентой ещё одну контейнерную, которая добавит в нашу целевую компоненту через пропсы нужные данные.

В нашем случае нас интересует props.match.params!

Интересный коммент №1

У кого не работает, продублирую путь решения

1 import { useParams } from 'react-router-dom'; - нужно это просто сверху импортировать
2 export function withRouter(Children){
return(props)=>{

            const match  = {params: useParams()};
            return <Children {...props}  match = {match}/>
        }

    } - добавить это перед классовой компонентой
    Остальное делаем как Димыч
    Как я понял, суть решения в том, что мы используем Хук - UseParams, он позволяет достучаться до url
    Но так как нельзя хуки и классы мешать, мы берем и заворачиваем наш хук в функцию, далее из функции, которая как раз совпадает с нерабочим withRouter

Интересный коммент №2

    <!-- Ребята, кто писал проект на react router v6, нужно использовать хуки, а не HOC шаблон. Но по скольку в курсе наша контейнерная компонента ProfileContainer - классовая компонента, то мы не можем использовать хуки в классвовых компонентах. Есть решение из оффициальной документации - создать функцию-обёртку, которая по принципу идентична к withRouter:import {
    useLocation,
    useNavigate,
    useParams,

} from "react-router-dom";

// wrapper to use react router's v6 hooks in class component(to use HOC pattern, like in router v5)
function withRouter(Component) {
function ComponentWithRouterProp(props) {
let location = useLocation();
let navigate = useNavigate();
let params = useParams();
return (<Component
{...props}
router={{ location, navigate, params }}
/>
);
}

    return ComponentWithRouterProp;

}
И теперь, эту функцию нужно использовать👇
export default connect(mapStateToProps, {setUserProfile})(withRouter(ProfileContainer));
Затем, в классе ProfileContainer мы можем получить айдишку пользователя, прописав:
let profileId = this.props.router.params.profileId;
И все, дальше меняем URL запроса, и обновляем данные профиля в зависимости от айди пользователя -->

Интересный комент №3 (свежий вариант)

<!-- Опциональные параметры больше не поддерживаются в react-router-v6, поэтому в документации советуют делать так (погуглите useParams v6.6.1) :
App.js:
<Route path="/profile/">
   <Route path=":userId"  element={<ProfileContainer/>} />
   <Route path="me"        element={<ProfileContainer/> }/>
</Route>
Здесь я сделал отдельный Route по клику на кнопку профайл и захардкодил свой юзер айди (поскольку здесь никакие параметры не передаются), но суть понятна.

В нашем контейнере нам не нужно создавать дополнительную компоненту с помощью withRouter (он больше не поддерживается), но нам нужно импортировать функцию useParams из react-router-dom.
Чтобы всё работало, переделываем классовую компоненту ProfileAPIComponent в функциональную, вместо componentDidMount() пишем:


import {useParams} from 'react-router-dom'
import { useEffect } from 'react';


const ProfileAPIComponent = (props) => {

  const params = useParams()

  // на случай, если айдишник не пришёл
  if (!params.userId) {
    params.userId = вашАйди
  }

  useEffect(() => {
   axios.get(`com/api/1.0/profile/${params.userId}`)
   .then(response=> {props.setProfile(response.data)});
   })

  return (
    <Profile profile= {props.profile} />
  );
}

Ну а connect от react-redux оставляем, как и было, ничего не трогаем.
const ProfileContainer = connect(mapStateToProps, {
    setProfile
}) (ProfileAPIComponent) -->

61. - React JS - cookie, login в теории, auth/me

Ребят, нетленная классика - логин через cookie!!! Понимание этого authentication flow ОБЯЗАТЕЛЬНО!!!

Позже мы с вами рассмотрим и JWT-токены! Ничего сложного, по сути тоже самое, только чуть больше логики написать. Чуть больше!

62. - React JS - практика, follow-unfollow api

Мы с вами реализовали полписку и отписку. Но... Не до конца! Вся логика наша свелась к просто изменению стейта redux при нажатии на кнопки. А нам ведь нужно на сервер запрос отправить.

Сценарий такой:
1 кликаем на кнопку подписаться
2 шлём запрос на сервак
3 сервак говорит: всё ок, подписались
4 после этого только диспатчим экшен в стор

63. - React JS - практика, DAL, axios.create

Друзья, есть 2 истины, которые незыблимые и которые нарушать нельзя: буква S в аббревиатуре SOLID и недублирование кода!

Мы должны всеми правдам и неправдами стремиться к букве S (Single responsibility Principle) и УСТРАНЯТЬ дублирование кода.

Именно про это данный урок:
1 мы выносим в отдельный объект респонсибилити, связанную с взаимодействием с сервером (условный DataAccessLayer) и устраняем дублирование засчёт использования инстанса (экземпляра) axios, который можно создать с помощью axios.create

64. - React JS - практика, button disabled (follow\unfollow)

Нужно ДАТЬ пользователю понять, что JS сейчас в фоне (ajax) отправляет запрос на сервак и ждёт от него овтета. Мол, не нужно нажимать по 100-500 раз кнопку отправить, залогиниться, лайкнуть.. Мы уже, в процессе, подожди...

Но пользователь всё равно будет пытаться "ускорить" этот процесс))

И мы должны ему в этом помешать)

Для этого нужно либо показать крутилку вместо кнопки, либо.. задизеблить саму кнопку: disabled={true}

65. - React JS - урок redux-thunk в деталях (теория)

Ребят, без thunk далеко не уедешь! Что такое thunk?
thunk - это функция, которая как правило делает асинхронную операцию (чаще всего, это ajax-запрос) и несколько диспатчей обычных экшенов!

Помимо ajax-запросов, внутри санки можно запустить другую асинхронщину, например setTimeout, setInterval либо сделать асинзронный запрос к indexedDB...

thunk - это функция бизнес логики (BLL уровень).

thunk - это функция, которую можно задиспатчить. Для этого ВАЖНО, чтобы стор понимал, что делать с санкой-функцией, которую задиспатчили. Для этого мы к стору применяем (applyMidleware) thunk-middleware - промежуточный слой, который будет перехватывать dispatch логику и запсукать санку.

Интересный комент №1

Замыкание, описанное здесь на 20:00 является частным случаем каррирования функций (function currying). Это паттерн, когда функция вместо нескольких параметров принимает только один, и возвращает функцию, ожидающую следующий параметр (и так далее), пока не будут заданы все параметры, после чего уже выполнится тело функции. Вызов такой каррированной функции выглядит как последовательность вызовов функций: doSomething("with this")("and this")("and even this")
Самое полезное свойство каррированных функций в том, что конечный результат является всё ещё функцией, которую предстоит выполнить (т.е. она не выполнена), но её предыдущие параметры ей уже заданы. Это полезно, когда вам нужно передать коллбэк, и у вас уже есть значения части аргументов этого коллбэка, но вызывать его будете не вы, соответственно вам нужно каким-то образом «прилепить» к коллбэку известные аргументы, и тогда где бы этот коллбэк не был вызван, в него уже будут зашиты значения всех каррированных аргументов.

66. - React JS - урок redux-thunk в деталях (практика)

Библиотека redux-thunk:
https://github.com/reduxjs/redux-thunk

67. - React JS - урок redux-thunk 2 в деталях (практика)

68. - React JS - Redirect

в 2022 году вместо <Redirect /> используем <Navigate />
Автоимпорт почему-то не сработал (скорей всего сейчас нужно использовать какие-то хуки... предполагаю), так что, чтобы работало проимпортируйте функцию
import { Navigate } from "react-router-dom";

69. - React JS - High Order Component (hoc)

HOC это:

- High Order Component
- Компонент Высшего Порядка
- Функция, которая на входе в параметрах принимает компонент, а на выходе возвращает новый компонент - контейнерный компонент для переданного в параметрах компонента.

HOC позволяет нам применять какое-то поведение к разным компонентам, не дублируя код.
Иначе: HOC позволяет нам создавать однотипные контейнерные компоненты для разных целевых компонент. А задача контейнерной компоненты - дать целевой презентационной компоненте какие-то данные\поведение.

Из популярных всех известных HOC-ов мы с вами уже знаем connect и withRouter
Правда connect - не совсем HOC если совсем придраться уже: connect после первого вызова вернёт нам HOC. И мы его уже вызываем второй раз.
А сама функция connect не может быть хоком, так как она принимает mapStateToProps и mapDispatchToProps, а настоящий HOC должен принимать в параметрах КОМПОНЕНТ.

Инт коммент №1

Про hoc слышал, но не использовал. В принципе, можно в hoc вынести всю логику по определению залогинен ли пользователь или нет. Один раз в hoc прописать componentDidMount() { this.props.checkToken(); } и использовать, где хочешь. Спасибо! Как всегда полезно!

Инт коммент №2

Мое мнение. вот если бы фразу про два раза создания НОК разделить на две отдельные фразы, было бы слегка понятнее. 1. мы создаем withAuthRedirect и выносим туда логику проверки авторизации. в нее передаем нашу компоненту. 2 Нам надо узнать значение isAuth, для этого мы используем наш добрый и хорошо знакомый connect, который легко позволяет получить доступ к state..

70. - React JS - функция compose

Функция compose позволяет нам писать более компактный и читаемый код.
Идея простая: мы делаем композицию (комбинацию) каких-то функций. Первая в очереди функция (последняя переданная в compose) получает аргумент и обрабатывает его, возвращая результат, который передаётся в следюущую функцию в цепочке. И так происходит до самого конца. Что-то типа конвейера. В нативном JavaScript такой функции нет, и обычно её реализация присутствует в различных библиотеках! Мы будем поключать эту функцию из библиотеки redux

mport { compose } from "redux"; // у меня происходит только через импорт из библиотеки "redux", нежели connect из react-redux...

Разница в импорте между redux, react-redux, redux-thunk!
redux - поток, похожий на поток, с одним хранилищем, который можно использовать в любой среде, которая вам нравится, включая vanilla js, react, angular 1/2 и т. д.

react-redux — привязки между redux и react. Библиотека предлагает набор хуков реакции — useSelector()и useStore()для получения данных из хранилища, и useDispatch()для отправки действий. Вы также можете использовать эту connect()функцию для создания HoC (компонентов более высокого порядка), которые прослушивают изменения состояния хранилища, подготавливают свойства для обернутого компонента и повторно отображают обернутые компоненты при изменении состояния.

redux-thunk — промежуточное ПО, позволяющее писать создатели действий, которые возвращают функцию вместо действия. Преобразователь можно использовать для задержки отправки действия или для отправки только при выполнении определенного условия. Используется в основном для асинхронных вызовов API, которые отправляют другое действие в случае успеха/неудачи.

71. - React JS - setState, local state

setState() - более применяется для UI, с большим акцентом на UX - переключение вида меню, вызов модального окна и т.д. setState() - как асинхронный метод (изменяет state не моментально )

Инт коммент №1

Надо было вызывать один и тот же метод и делать так: this.setState( {editMode: !this.state.editMode} ). То есть мы всегда меняли бы на обратное значение. Меньше кода)

Инт коммент №2

Димыч спасибо за урок. Решил попробовать сделать вместо класса функциональную компонету+хук (делаю это в первые) вот что вышло:

<!-- const ProfileStatus = (props) => {
    const [editMode, activateEditMode] = useState()
    return (
        <div>
            {!editMode &&
                <div>
                    <span onDoubleClick={() => activateEditMode(true)} >{props.status}</span>
                </div>}

            {editMode &&
                <div>
                    <input autoFocus={true} onBlur={() => activateEditMode(false)} value={props.status} />
                </div>}
        </div>
    )
}
export default ProfileStatus -->

Инт коммент №3

Димыч и все самураи, привет! А если onMouseLeave вместо onBlur? Отвел курсор с поля input - и опять editMode: false. React, Redux - это круто!

72. - React JS - обновляем create-react-app

Инт коммент №1

Ну кому интересно. NPM и YARN работают немного по разному. Когда начнете использовать Docker и будете стремится к минимальному размеру docker image а это очень важно так как это деньги так как у сервисов типа AWS, GCP, AZURE (это самые популярные их больше) есть квоты а за превышение берут деньги.

Тут вы и заметите в чем разница. Я думаю это тут и сработало.

Разница в чем - NPM когда устанавливает пакеты даже в случае с удаленными node.modules он может их установить из кэша то-есть если у вас была установлена например в package.json версия ^6.1.1 а вы хотите поставить самую последнюю но не будете изменять в package.json то он сам будет решать какую ставить из кэша версию или самую новую. Не знаю по какому принципу он решает.

А вот YARN немного тупее и он берет бежит по всем пакетам и просто их пере-устанавливает.

Так же. будете окутаны с YARN он классный и быстрый но когда вы добавляете какой-то пакет он так же бежит и пере-устанавливает остальные пакеты если может,
а вот это вообще не очевидно. Так что во взрослых. проекта хорошей практикой хардкодить версию зависимости не использовать ни каких знаков перед версией.

73. - React JS - http put, local state

Запрашиваем статус с сервера, и отправляем статус на сервер!!! Вместе с PUT-запросом мы можем отправлять payload - полезную нагрузку. Такую нагрузку можно отправлять только с post и put запросами, с get и delete - нельзя!

Инт коммент №1

Для тех у кого после отключения фокуса с input не меняется значение без обновления страницы проблема в следующем.
1)проверяем PUT запрос проходит в ответе получен result code 0. Может быть лимит на запросы.
2)Если п.1 все хорошо. то проблема в том что в глобал стейт не записывается новое значение, это можно проверить самому через дебаг или на крайний случай добавляете alert(this.props.status) в deactivateEditMode.
3)Сама проблема в if который находится в санке updateStatus проверяйте её, она просто не видит resultCode = 0 и не даёт изменить глобальный стейт.

[API.JS]

updateStatus(status) {
return instance.put(`profile/status`, { status: status }).then((response) => response.data);
},

[profileReducer.js]

export const updateStatus = (status) => (dispatch) => {
profileAPI.updateStatus(status).then((data) => {
if (data.resultCode === 0) {
dispatch(setStatus(status));
}
});
};

crecker05ru

74. - React JS - componentDidUpdate

Компонент монтируется один раз. А потом, когда в нём меняется локальный стейт либо кто-то извне хочет перерисовать компонент и закинуть в него новые пропсы.. То срабатывает метод жизненного цикла componentDidUpdate

Важный момент: этот метод срабатывает уже после отрисовки, то есть находясь в нём мы имеем актуальные самые свежие this.state и this.props. И для того, чтобы сравнить у нас была возможность, находясь в этом месте проанализировать, а что именно изменилось (пропсы или стейт), React забрасывает в метод componentDidUpdate предыдущие props и state.

В данном методе жизненного цикла разрешено вызывать setState, но так как это может привести к зацикленности, делать это нужно аккуратно и всегда внутри правильного условия!

Инт комент 1

Смотрите, когда мы обновляем страницу, происходит два телодвижения: this.props.getUserProfile(userId) и this.props.getStatus(userId). Каждый из этих запросов ждет ответа от сервера.
Если профиль приходить БЫСТРЕЕ чем статус, то рендер происходит с ОДНИМ НЮАНСОМ - так как сервер нам ещё не прислал ответ со статусом, то в ЛОКАЛЬНЫЙ стейт записывается ПУСТОЙ статус, потому что он у нас в глобальном стейте тоже пустой.
Затем, когда уже от сервера приходит ответ со статусом, то происходит новый рендер, где мы видим статус на странице, так как он записался в глобальный стейт и соответственно есть в глобальных пропсах, НО статус в ЛОКАЛЬНОМ стейте НЕ МЕНЯЕТСЯ и остается ПУСТЫМ. В итоге при даблклике в инпуте будет пустота.
Тут самое главное понять, что рендер происходит молниеносно. Мы не видим первый рендер с пустым статусом, а видим только итог второго, когда статус уже пришёл и отображается на странице, но не в импуте. Так как локальный стейт уже сформировался с пустым статусом в первом рендере, то во втором рендере статус туда уже не запишется и поэтому будет пустой инпут.
Для этого нам и нужен componentDidUpdate, который всегда вызывается при каждом новом рендере. Когда у нас происходит второй рендер, мы сверяем старые пропсы в локальном стейте с новыми пропсами из глобального. Если они различаются, то с помощью setState изменяем пустой статус в пропсах локального стейта на новый статус, который пришел в новых пропсах.

Отличное обьяснение, но остается один вопрос - почему статус в локальном стейте не меняется когда меняется глобальный? он ведь инициализируется как state: this.props.state, а значит должен меняться когда меняется глобальный стэйт.

Потому что локальный стейт инициализируется при первом рендере и дальше живет своей жизнью. Да, после того, как пришел статус, происходит новый рендер, но локальный стейт остается тем же, он не обновляет данные и сохраняет значение, которые были ему переданы при первом рендере. Для этого нам надо дать указание, при каких условиях он должен обновить данные в локальном стейте, поэтому мы и вводим метод componentDidUpdate где вручную сравниваем старые данные локального стейта с новыми пропсами и если они отличаются, то обновляем локальный стейт.

коммент хороший, я пол дня просидел , чтобы осмыслить этот урок, долго ковырялся, нашел еще кое что (понятно, кому то очевидно или об этом имелось ввиду, но тем не менее). Чтобы лучше осмыслить сделайте следующее (имена компонент могут отличаться, но логику поймете):

- ваш статус на серваке должен быть пустой строкой.
- в profilePageReducer где initialState (это объект) задайте свойство status не пустой строкой , а допустим "initial status".
- закомментите код этого урока.
- в браузере заново проинициализируйте проект , в новой вкладке , например http://localhost:3000/
- зайдите в профиль вы увидите прочерки (если вы как Димыч при пустом this.props.status ставили прочерки)
- дабл клик по статусу , вы увидите "initial status" , это как раз подтягиватеся из profilePageReducer из initialState, т.е. из редаксовского стейта.
- уберите фокус, это перезапишет статус на серваке.
- обновите страницу, и будет строка "initial status" , дабл кликл опять "initial status".

о чем это говорит ?
о том, что :

- при первой инициализации отрисовывается (выводится) в тег спан то , что пришло с сервака , то есть this.props.status (естественно, в профайлконтейнере (или точнее благодаря (через него) )мы делаем запросы на сервак)
- но ! в локальном стейте у нас записано то, что profilePageReducer , помните, я писал выше "initial status".
  Именно по этому при клике мы видим то, что в локальном стейте. Если вы уберет фокус из инпута, то запустите процессе перезаписи локального стейта.
  То есть при первой отрисовки у нас нет ничего, что перезаписало бы локальный стейт значением с сервака

- обновите на сервака статус другим значением
- Расскомментите код этого урока у себя, и попробуйте в браузере заново проинициализируйте проект , в новой вкладке , например http://localhost:3000/ вы увидите значение из предыдущего шага. То есть код этого урока перезатирает локальный стейт глобальным

*

хочу добавить , что в уроке сделано так :
state = {
editMode: false,
status: this.props.status,
}
если бы Димыч прописал status: "bla bla' , то осмысление лучше было бы (ну у меня ) , это не упрек, а помощь тем, кто пытается понять. Это даст понимаение того, что в данном коде у нас при первой отрисовки страницы локальный стейт не затирается данными с сервака.

Вопрос без ответа 1

В самом начале видео примерно с 45ой секунды Димыч описывает проблему последовательности получения Profile и Status: если первый приходит Status, то все ок, а если первый приходит Profile - то не ок. Мне не понятно одно. Ведь и this.props.getStatus(userId) и this.props.getUserProfile(userId) меняют глобальный state и по идее после каждой смены стейта та часть дерева, которая связана с этими изменениями должна была и так перерисоваться без использования componentDidUpdate. Или тут это как-то с асинхронностью связано?

Вопрос без ответа 2

Не совсем понятно, зачем уведомлять компоненту, что она обновлена, используя componentDidUpdate. Ты говоришь, что для синхронизации state. Но с чем мы его должны синхронизировать?
Если изменились props или state, то с чем мы должны синхронизировать state при вызове this.setState({status: this.props.status})? Надеюсь, потом ясней будет.

75-77 устаревшие материалы изучал по https://www.youtube.com/watch?v=1_4yH0C9iq0&t=1624s&ab_channel=REDGroup
https://medium.com/nuances-of-programming/%D0%BA%D0%B0%D0%BA-%D0%BB%D0%B5%D0%B3%D0%BA%D0%BE-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B2%D0%B0%D1%82%D1%8C-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BD%D0%B0-react-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-react-hook-form-9749c8cb3387

75. - React JS - redux-form введение (login)

Форм на сайте ВСЕГДА очень много. И с формами связано очень много нюансов. Ну, основной нюанс - это валидация, наверное. Приходится изобретать много колёс. А колёса - это не очень хорошо!!! И вот есть библиотека redux-form. Что она делает?

Предоставляет нам специальынй reducer, который мы должны закомбайнить в общий наш стор. И с помощью этого редьюсера redux-form за кадром будет делать всю магию flux-круговорота, а так же предоставлять много возможностей по валидации!!! Начнём с самой популярной формочки - страницы авторизации - Login Page

Дефолтное поведение кнопки - сибмитить форму (отправлять данные на сервер)
Наша форма вызывает метод handleSubmit из контейнерной компоненты => handleSubmit - прокидывает контейнерная компонента с помощью хока (reduxForm) => handleSubmit вызовется во время процесса логинизации (нажатие на кнопку Логин)=> внутри handleSubmit'а вызовится то что пришло в контейнерную компоненту через onSubmit и стыкуются данные в обект для сервера.

76. - React JS - redux-form опять про базовые вещи

Димыч, было бы круто, если бы ты разобрал библиотеку Redux-Table. С возможностью редактирования таблицы.
МастХев тема в бизнесе.

77. - React JS - redux-form field validation (валидация, ошибки). Осторожно Замыкание!

Валидация, проверка введённых пользователем данных, обратная связь для пользователя в виде подсветки ошибок и текста ошибки!!! Всё это ОЧЕНЬ важно. Писать свой велосипед ЗАПРЕЩЕНО в реальной жизни - это расточительство бюджетов компании и заказчика. А вот заюзать уже имеющиеся инструменты - это круто!

Летим!!! Создадим с вами функции-валидаторы - функции, которые принимают значение на входе, а на выходе возвращают либо undefined (если значение прошло валидацию, то есть значение корректно), либо "текст сообщения об ошибке";

А чтобы красиво отображать сообщения об ошибке и вообще как-то стилизовать элементы с ошибкой, создадим вокруг обычных элементов input и textarea свои контейнерные компоненты, в которых помимо этих примитивных элементов будут ещё и элементы, которые будут отображать текст ошибки если нужно, а так же добавлять к элементу css класс!

79. - React JS - stopSubmit (redux-form)

Ребята, почему я засмущался сразу фиксить ситуацию абы как? Потому что по-прежнему я топлю за нормальную архитектура)) И хочу сделать по феншую всё! Ситуация вот какая: валидация ("показывание ошибок") по сути у нас реализована на уровне UI (то есть redux-form этим вопросом занимается).

А тут про ошибку стало известно бизнесу (BLL), потому что от сервака (DAL) пришёл ответ, мол, что-то не так.

И эту ситуацию можно было бы решить несколькими способами. Вот размышление на этот счёт:

Комент 1
А КАПЧУ ПРОСТО СДЕЛАТЬ, ты бы мог в видос вставить, img и field отображать, когда капча пришла и в img url ставить ссылку на фото этой капчи

80. React JS - инициализация приложения

Как только приложение загрузилось (SPA), а именно загрузилась HTML-страница и код нашего приложения.. По сути уже можем показать пользователю что-то. Мы так и делали.. Но... Готово и к показу наше ReactJS-приложение??? Что именно показывать: страницу логина или запрашиваемую в урле страницу? Какую тему показать: светлую или темную.. Какой язык: ru, en или es???
А если интерфейс ещё более гибко умеет настраиваться (панельки, кнопки, расположение блоков и так далее)?? Хорошо, если эти данные храняться в localStorage и можно быстро среагировать (кстати, неплохая доработка может быть, но есть нюансы - версионность и так далее)...

Чаще всего нам потребуется сделать на старте запрос на сервак (и не один возможно), для того, чтобы получить стартовые данные для конкретного пользователя, ну и вовсе определить, а есть ли конкретный пользователь, или он аноним.
Мы пишем SPA ReactJS-приложение. По своей философии оно не отличается от тех же мобильных приложений. А при запуске мобильного приложения мы чаще всего видим что-то вроде splash-эакрана (https://en.wikipedia.org/wiki/Splash_...
, мол, мы загружаемся\запускаемся...

Предлагаю и я сделать тоже самое с нашим приложением, чтобы избежать ненужных проблем с редиректами, морганиями и прочим не очень приятным для конечного пользователя дерганьем!

Комент 1

24:42 Где работаем с промисами можно сделать так.
export const initializeApp = () => async (dispatch) => {
await dispatch(getAuthUserData());
dispatch(setInitializedSuccess());
};
Может кому-нибудь зайдёт

Комент 2

G P
5 месяцев назад (изменено)
в новой версии не работает withRouter(), а history попадает в пропсы именно от туда.
Вместо withRouter используется хуки useParams(), но там нет уже history, а только params.
history можно заменить на navigate. navigate Приходит в параметры через хуки useNavigate().
Я написал HOC, чтобы передать хуки в пропсы, так как хуки нельзя использовать в классовых компонентах.
Ниже описание HOC:
import React from "react";
import { useNavigate } from 'react-router-dom';

    export const withNavigate = (Component) => {
        let RedirectTo =(props) => {
            return < Component {...props} navigate={useNavigate() } />
       }
            return RedirectTo;
       }

В ProfileContainer.jsx:
1 Импортируете этот HOC
2 В compose добавить withNavigate,
3 В componentDidMount добавить:

if (!userId) {
this.props.navigate('/login');
}
Но в принципе можно было бы вообще этого не делать редирект и так происходит нормально в новой версии. Поэтому возможно уже многие хоки убрали.

Комент 3

​ @Ivan Ivanov я создал свой хок withRouter, куда засунул все нужные свойства сейчас и в будущем по курсу этому
вот пример кода:
import React from "react";
import { useLocation, useNavigate, useParams} from "react-router-dom";

export const withRouter = (Component) => {
function ComponentWithRouterProp(props) {
let location = useLocation();
let navigate = useNavigate();
let params = useParams();
return (
<Component
{...props}
router={{ location, navigate, params }}
/>
);
}
return ComponentWithRouterProp;
}

А дальше как с обычным HOC
добавить в компос и так далее, код в profileContainer стал:
componentDidMount() {
debugger
let userId = this.props.router.params.userId;
if (!userId) {
userId=this.props.authorizedUserId;
if (!userId) {
this.props.router.navigate('/login');
}
}

Комент 4

Кто не хочет переписывать App.js в класс используйте хук useEffect.
useEffect(( ) => {
props.initializeApp();
}, [ ] )

Он заменяет componentDidMount

81. - React JS - селекторы (reselect part 1)

82. - React JS - mapStateToProps (reselect часть 2)
      Селекторы - крутая концепция. Но она приводит к следующим ситуациям неприятным, так как функция mapStateToProps вызывается ВСЯКИЙ раз, когда в стейте меняется что-либо, даже не касающееся этого mapStateToProps, а значит селектор запускается повторно:

1) неудобно дебажить
2) селектор может содержать сложную и напряжную для процессора логику, а значит лишние перерасчёты будет делать когда не нужно
3) селектор может возвращать новый массив\объект с теми же элементами\структурой и из-за этого будет происходить перерисовка компоненты напрасная

IT-KAMASUTRA
2 года назад
useSelector просто альтернативный более удобный способ доставание данных из стейта! Внутренность такая же и кол-во перерисовок! Вот-вот на днях в 2.0 сезоне будет об этом инфа

83. - React JS - подключаем reselect (reselect часть 3)

Ну что, друзья, какие проблемы у нас мы выяснили в предыдущих выпусках...
И нам нужно решение этой проблемы. Встречаем - библиотека RESELECT.

По-прежнему простые селекторы мы создаём руками. А вот более сложные селекторы, которые мы не хотим перезапускать, результат работы которых мы хотим как бы "запомнить", чтобы не делать отработку логики по-новой, так как не изменились данные, которые могли бы повлиять (зависимости) на иной результат, мы будем создавать с помощью функции createSelector

комент №1

очень путано и неуверенно..видно , что автор сам плавает в понимании использования селекторов, вместо того, чтобы просто сказать, что Reselect принимает: 1 Вариант - селекторы в виде списка, перечисляемого через запятую и функции - комбанейра (тот самый колбэк), которая в конце списка всегда и в качестве аргументов идут возвращаемые значения от выполнения предшествующих ее селекторов; 2 Вариант - Reselect принимает первым аргументом массив селекторов, вторым - ту же функцию - комбайнер, где в качестве аргументов идут возвращаемые значения от выполнения селекторов в предшествующем массиве...

84. - React JS - hook, useState, хуки

Зачем нам нужны хуки (hooks)??? Хуки - это функции, которые умеют делать что-то крутое и очень гармонично вписываются в инфраструктуру реакта.

ReactJS хочет уйти в сторону и не использовать классовые компоненты вовсе. Но без классовых компонент мы не могли обойтись: нам иногда (или часто) нужен стейт внутри компоненты, а так же нам нужны методы жизненного цикла компоненты, чтобы делать побочные эффекты (side-effects) (componentDidMount\componetnDidUpdate), предотвращать перерисовку лишнюю (shouldComponentUpdate), зачищать мусор (componentWillUnmount) и ещё всякое разное...

Нам НУЖНЫ были классовые компоненты. Но разработчики ReactJS решили научить функциональные компоненты решать перечисленные выше ситуации иным способом: не с помощью методов жизненного цикла и локального стейта, а с помощью хуков.

И так, начинаем с самого простого и понятного: useState.
useState позволяет нам внутри функциональной компоненты доставать состояние, сохранённое для этой компоненты на прошлом этапе отрисовки. Для неискушенного обывателя это выглядит, будто внутри самой функциональной компоненты у нас есть "локальный стейт", точь-в-точь, какой у нас был в классовой компоненте (this.state, this.setState)

А вот та самая статья про разжеванное объяснение от создателя:
https://habr.com/ru/company/ruvds/blog/445276/

Интересный комент 1

2 дня читал про хуки (офф доку, статью из прошлоги видео и прочее). Говорят: не рассматривайте useEffect в понимании жизненнго цикла. Ну, у меня не было особого понимания жизненного цикла, так что это для меня не было проблемой ))) но ... аналог componentWillUnmount - у меня всегда пишется в отдельном useEffect просто потому, что другие эффекты зависят от разных переменных и ихний useEffect срабатывает довольно часто, в то время как допустим "отменить все запросы к серверу, потому что пользователь ушел со страницы" - мне надо делать только 1 раз, когда он реально ушел ... и получается всегда отдельный useEffect под это. И это типа прямая аналогия с componentWillUnmount чего делать не рекомендуется, но я ХЗ как тут быть еще (((

    Интересный комент 2

    А я не стороннник ООП, но сторонник ФП. Потому что со временем продукт/бизнесс усложняется... появляется больше side эффектов и вообще complexity (не знаю как перевести, на испанском complejidad). Поэтому хорошо использовать ФП... Всем рекомендую вот это "Введение в ФП для Javascript" (https://github.com/MostlyAdequate/mostly-adequate-guide-ru). Попробуйте затянет... Ведь будущее за ФП (это подтверждают такие технологии / языки как Go, Elixir, F#, Kotlin way.... ) Возможно я и ошибаюсь, но ФП позволяет существенно уменьшить side effects и также написание/покрытие тестами

Интересный комент 3
ребят, когда массив пустой, это как сказал дима обман react и есть случае что будут ошибки, и тд, всегда можно решить проблему, нужно понять, что эффекты это не методы жизни, никто не говорил, что useEffect должен срабатывать один раз, вот как я переделал profileContainer c userId:
let userId = props.match.params.userId
if (!userId) {
userId = props.ownId
if (!userId) {
props.history.push('/login')
}
}
useEffect(() => {
console.log('prof')
if (userId) {
props.getProfile(userId)
props.getStatus(userId)
}
}, [userId]),
useEffect срабатывает при каждом изменении userId, но я поставил в внутри условие что бы не было лишних, пустых запросов. Помните проблему, что если мы тыкнем на profile, находясь на странице другого юзера, по логике нас должно перекинуть на нашу, но didMount не даст этого сделать, приходилось обновлять страницу, а с эффектом все встало на свои места, нажимая на профиль я буду переходить на свой профиль, потому что didMount ВИДЕЛ что компонента вмонтирована и при нажатие на profile, мы по факту оставались там же.

85. - React JS - hook, useEffect, хуки

Хук (hook) useEffect позволяет нам сделать какой-то сайд-эффект после того, как компонента отрендериться. Что-то вроде методов жизненного цикла в классовой компоненте: componentDidMount + componentDidUpdate (2 в 1)

useEffect сложен по-своему, но очень крут! Попробуем на простом примере разобрать его действие!

А вот та самая статья про разжеванное объяснение от создателя:
https://habr.com/ru/company/ruvds/blo...

Интересный комент №1

хуки запрещено писать в условиях, в циклах
пример как вынести в 2 переменные результат хука - значение и функцию - сеттер значения
let [applesCount, setApplesCount] = useState(8);

нельзя в функциональной компоненте иметь sideEffect
useEffect - это тоже хук, мы отдаем реакту функции как эффекты которые должны быть применены когда компонента отрисуется
принимает функцию и массив с зависимостями
useEffect( ()=>{ ... }, [a,b,c])
если не передать зависимости - useEffect будет выполняться после каждой отрисовки
если передать пустой массив как зависимость - useEffect будут работать как componentDidMount

Интересный комент №2

Супер!!! Всё очень понятно о hook useEffect. Ко всему добавлю что этот хук ещё имеет возможность делать отписку, что-то типа componentWillUnmount, внутри хука в конце нужно возвращать функцию в которой будет происходить какая-то логика в тот момент когда компонент будет демонтирован, например
useEffect(() => {
window.addEventListener('scroll',handleScroll)
return () => {
window.removeEventListener('scroll', handleScroll)
}
},[])

Обязательно гуглим эту тему в официальной документации!

2.01. - Введение, TypeScript, Apollo, AntDesign, WebSocket / React JS - Путь Самурая 2.0

В новом сезоне нас ждёт:

- строгая типизация в связке React + TypeScript
- красивый внешний вид (CSS фреймворк\библиотека Ant Design)
- реактивное двустороннее взаимодействие с сервером с помощью WebSocket (socket.io)
- альтернативное Rest API взаимодействие с сервером с помощью языка GraphQL
- альтернативный Redux стейт менеджмент с помощью Apollo, играющего по правилам GraphQL

86. - Virtual DOM - React JS

VirtualDOM - то, благодаря чему ReactJS так взлетел. Он говорит: настоящий DOM - это дорого, это перерисовки, это ресурсы, дёрганья, и так далее... Давайте Я (REACT) брать брать JSX из компонент и на основе его формировать Virtual DOM - набор оъектов, из который потом буду превращать в настоящий DOM. Зачем этот промежуточный слой нужен?
Для того, чтобы прежде чем идти на основе Virtual DOM строить настоящий DOM... Я смогу сравнить тот VirtualDOM, который у меня уже был, с тем, который я получил в текущей отрисовке из компонент, и... Сравнить их. И если изменения есть, я пойду и точечно эти изменения перерисую в настоящем DOM.

Как результат - коллосальный прирост производительности по сравнению с тем, как с DOM работали раньше (шаблонизаторы, innerHTML и так далее)...

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

Farragut West
3 года назад
Virtual DOM
Document Object Model
Компонент возвращает jsx разметку, разметка транспилируется в js который генерирует html разметку, браузер парсит html страничку и создает DOM дерево, на базе этого дерева браузер создает визуализацию
knockout.js перерисовывал всю страницу каждый раз при изменениях в DOM
потом пришел React и говорит давайте я возьму на себя контроль за DOM элементами
VirtualDOM - упрощенные промежуточные обьекты при изменении которыз не происходит перерисовки страницы
Reconciliation
когда компонент хочет перерисоваться он возвращает реакту новую jsx разметку, реакт создает новую версию VirtualDOM (условно дешев), после реакт делает Reconciliation - быстрыми алгоритмами сравнивает старую версию Virtual DOM и новую, и на базе найденных отличий (если отличия есть) точечно обновляет части реального (не virtual) DOM
document.createElement создает елемент настоящего DOM
React.createElement создает елемент virtual DOM
оптимизация благодаря ключам (key) в списках

87. - shouldComponentUpdate, PureComponent, memo - React JS

INTERpol 21
6 месяцев назад

1 Для компонентов класса react предоставляет React.PureComponent базовый класс.
2 Для функционального компонента react предоставляет React.memo HOC (компонент более высокого порядка).
Главная суть урока. Работа с перерендером компонентов, оптимизация работы с компонентами и проверкой изменения стейта.

1 Используйте shouldComponentUpdate(), чтобы указать необходимость следующего рендера на основе изменений состояния и пропсов shouldComponentUpdate() вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true

2 React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.Кроме того, метод shouldComponentUpdate() базового класса React.PureComponent пропускает обновление пропсов для всего поддерева компонентов. Убедитесь, что все дочерние компоненты также являются «чистыми».

3 React.memo — это компонент высшего порядка.React.memo затрагивает только изменения пропсов. Если функциональный компонент обёрнут в React.memo и использует useState, useReducer или useContext, он будет повторно рендериться при изменении состояния или контекста.Этот метод предназначен только для оптимизации производительности. Не полагайтесь на него, чтобы «предотвратить» рендер, так как это может привести к ошибкам.

4 Так же HOOK useMemo. Для мемонизирования значения и оптимизации рендера и производительности(Да тема немного другая и не сильно относиться к чистым компонентам!)
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

88. - pure function (чистая функция) - React JS

ReactJS в первую очередь про функциональное программирование. Есть основная концепция - ЧИСТАЯ ФУНКЦИЯ, которую вам нужно понимать.

По сути, теория-теория-теория.. Хотя по факту практика-практика-практика)))

Какие момент ынужно помнить и понимать на мой скромный взгляд, когда вас спросят про фистую функцию?
1 immutability (имьютабельность, неизменяемость) - входные данные, пришедшие в функцию, эта функция не должна менять (речь про объекты и массивы, так как по ссылке они передаются, поэтому делаем копию)
2 отсутствие side-effects (пункт 1 связан с этим, а так же использование глобальных переменных, их модификация, асинхронные операции и что-то может быть ещё)
3 детерменированность\идемпотентность - сколько бы раз на вход чистой функции не подавали одно и тоже, на выходе чистой функции должен быть один и тот же результат
4 чистая функция должна вернуть (return) что-либо)))

89. - Тесты, jest, tdd, тестируем reducer - React JS

Тесты... Нужны ли они в ReactJS приложении? Безусловно - да!

Замедляют ли тесты разработку? Нет! Ускоряют? Нет)) А как тогда? По-разному! Плюс-минус одинаково!

Но тесты - это круто. Тесты позволяют всегда знать, что всё, что было единожды протестировано по-прежнему работает.

Всегда ли покрывают тестами приложение? Нет... Тут многро философии и ситуаций, оставим это...

И научимся базовым принципам - созданию простых тестов на нашу бизнес-логику! А наша бизнес-логика - это в первую очередь reducer!!!

Так же рассмотрим концепцию TDD - Разработка посредством тестирования. Этот подход говорит следующее:
1 сначала пишем тест
2 потом пишем код, который должен этот тест удовлетворить

https://www.youtube.com/watch?v=LGgMD_Evz_M&list=PLcvhF2Wqh7DMGR08yA6oNKJ7WCM0tGd4z&index=10&ab_channel=IT-KAMASUTRA

Serhii Khotsyk
2 месяца назад (изменено)
КОПИРУЮ КОМЕНТАРИЙ ОЗВУЧЕНЫЙ НИЖЕ, ДЛЯ ТЕХ У КОГО НЕ ЗАПУСКАЕТЬСЯ ТЕСТЫ В VSCODE. (так как он снизу и не все могут его заметить) 01.02.2023
Для тех, у кого возникает ошибка SyntaxError: Cannot use import statement outside a module" из-за импорта axios, мне помогло добавить в файл package.json свойство:

"jest": {
"transformIgnorePatterns": [
"node_modules/(?!(react-leaflet|@react-leaflet|d3-*|axios))"
]
}

Проблема в том, что разработчики axios че то изменили и теперь у всех кто использовал тесты с jest выдает такую ошибку. Решений в интернете много, но мне не помогло буквально ни одно, кроме этого

90. - redux-ducks рефакторинг - React JS

Ребят, мы засовываем всю логику (reducer, actions, thunk) в один файл согласно одному из соглашений, который имеет смешное название redux-ducks:
https://github.com/erikras/ducks-modu...

Так же в данном видео немного зарефакторим код, устраним дублирование и что-то ещё! отдохнём от React-а и немного просто пошаманим над нативным JS! Но в рамках Реакта ;)

Илья Иваник
(2 года назад изменено)
1 навания экшнов сразу делал уникальными, потому что, как только ты описал как оно работает (что стор кидает экшн по ВСЕМ редьюсерам) - стала очевидна эта проблема

2 примерно 3 видео назад переделал на asyc / await (где-то в других видео мельком увидел в коде их, вспомнил, что они существуют и подумал - нахрен эти .then у меня везде - читаемость кода снижается от них) ... Мне как-то всегда казалось, что если можно сделать const - то это как-то оптимизированнее что-ли?

3 все follow/unfollow (и подобные места) сразу делал через toggle, потому что мне всегда лень писать 2 функции там, где хватит одной (навреное это не всегда хорошо...) Но в итоге у меня на порядок проще код в этих местах

4 деструктуризация параметров. Изначально я имеено через нее начал писать, но бывает в компонент приходит реально много всякого и в итоге на местах, где это пробрасывается - раздувается код ради кода. Поэтому в послденее время я перешел на просто props. Но, пока что не понимаю как лучше делать. Дестуктуризация нагляднее, но год становится чертовски громоздким и ухудшается читабельность. Просто props проикидывать - читабельность хорошая, но когда надо найти или понять ЧТО, КУДА и ОТКУДА приходит - начинаются проблемы.

5 Все еще не люблю redux-forms, предпочел бы сделать через самописный хук типа useInput

6 Пагинатор)) я сделал такой, как он был у тебя показан в самых первых видео еще, где ты показывал макет: кнопка "подгрузить еще пользователей". Обычно я такой функционал вешаю просто на скролл (когда подскроливаешь к низу станицы - он тебе догружает еще), но тогда я еще не знал как вешать события на onScroll в react.

91. - chrome extensions для react и redux - React JS

Farragut West
3 года назад
Если создать нового пользователя в chrome то у нового пользователя не будет расширений (chrome extensions) прежнего пользователя - это удобно тем что можно быстро переключаться между пользователями и тем самым отключать мешающие расширения!

для redux тоже есть chrome extension как и (react dev tool) - Redux DevTools

react dev tool:
Вклaдочка Profiler - позволяет нам записывать рендеренги, отслеживать какая компонента сколько рендерилась, по какой причине, удобно для оптимизации производительности
Вкладочка Components - отображает всё дерево компонентов

Redux DevTools:
нужно добавить код в redux.store.js из инструкции https://github.com/zalmoxisus/redux-devtools-extension
Пример:
const composeEnhancers = window.REDUX*DEVTOOLS_EXTENSION_COMPOER* || compose;
const store - createStore(reducers, composeEnhancers(applyMiddleware(thunkMiddleware));
window.store = store;
после этого значёк redux екстенжена должен загореться зелененькм
перемотка стейта назад вперед

любой екстенжен нужно устанавливать с осторожностью - потому что может наловить персональных данных

\*92. - тестируем компоненты, тесты, react-test-renderer - React JS

93. - paginator, постраничный вывод - Практика ReactJS

Друзья, постраничный вывод и алгоритмика и математика, которые в него заложены - очень важны для вашего мышления. Постарайтесь это понять. Просчитать логику в голове, на БУМАГЕ. Paginator, paging, постраничный вывод - это касается не только визуализации на UI, но это вам пригодится в будущем, так как эти расчёты постраничной разбивки будут с вами всю жизнь: от rest api до распределённой обработки данных с помощью hadoop.

Ted Baggins
2 года назад
Советую тут не мудрить и просто использовать material-ui pagination. Предварительно надо установить их core и lab. Пример компоненты:

<!-- <Pagination count={pagesCount} variant="outlined" shape="rounded" siblingCount={2}onChange={(event, page) => { props.onPageChange(page); }}/> -->

Может знаешь ,как там цвет менять кроме 3 которые дефолтные ?

<!-- @Постороним в  , обернуть <ThemeProvider theme={theme}> <Pagination/> </ThemeProvider>.   А пример theme:
const theme = createTheme({
palette: {
primary: { -->
<!-- У <Pagination color='primary' /> -->

94. React.lazy и React.Suspense, зачем? - ReactJS

Самураи, привет. Зачем нужен React.lazy???
Ответ: чтобы в основной bundle (собранный для браузера большой общий js-файл) не попадали некоторые компоненты, которые с большой вероятностью не будут посещены большинством пользователей. А значит можно уменьшить размер итоговой сборки, чтобы ускорить стартовую загрузку всего приложения.

А тем компоненты, которые мы import-ируем лениво (React.lazy), они будут собраны в другие сборки-файлики и подгружены будут по сети по мере надобности. А может и вовсе не будут, если этой надобности не будет. Факт: мы загружаем только то, что нужно. А то что не загрузили, но оно понадобилось - подгрузим лениво в момент необходимости.

Да, пользователь из-за ленивой подгрузки контента (React.lazy) в момент обращения будет видеть ПУСТОТУ... Потому что React-у нечего отобразить...

Чтобы не было этой пустоты и пользователь понимал, что данные (а именно компоненты) грузятся - мы должны показать какую-то заглушку (fallback)... Для этого и нужен нам компонент React.Suspense

Илья Иваник
2 года назад (изменено)

К сожалению, если посмотреть на изначальный бандл, то он уменьшается с 520+KB до 510+KB, потому что наши чанки для profile и прочего - весят по 3-4KB ... т.е. как бы основная проблема первичного гигантского файла вообще не решена. Я надеюсь когда-то библиотеку реакт встроят в браузеры, тогда станет норм, а пока ... так себе это все... Ну или react SSR (да, я не знаю что оно такое, но как-то на него надеюсь интуитивно)))

Oleksandr Gochu
10 месяцев назад (изменено)
для тих хто заморочився з "react-router-dom: ^6.\*" і вирішив добити HOC-івску імплементацію, ділюся варінтом
на прикладі DialogsContainer(решту роутів пишуться по аналогії)

в App.js:
...
render(
...
const DialogApp = withSuspense(DialogsContainer);
...
return(
...

<!-- <Route path="/dialogs/*" element={<DialogApp />}/>} /> -->

...
і да, те шо можна, обгорунти всі роути Suspense - я побачив, але цікаво було добити таки HOC

95. - ReactJS + github pages, разворачиваем наш проект deploy




Github Pages - это упрощённый хостинг, который уже достаточно давно предолжил github всем нам: размещайте свои статические html\css\js странички в интернете!!! И будет вам счастье!

А наше ReactJS одностраничное приложение (SPA) - это ведь тоже просто набор статических зафиксированный готовых фаликов, какими бы они нам не казались сложными во время разработки! Потом по итогу Babel + Webpack упакуют это всё в обычные файлики.






96. - ReactJS загрузка изображения, shouldComponentUpdate fix

Часто нужно на сайт загрузить фотку, mp3-файл, архив и так далее. Сегодня мы с вами будем загружать аватарку профиля.

Несложно, принцип один:
1 добавляем тег input с type="file"
2 вешаем обработчик на событие onChange
3 берём файл, выбранный в input, и отправляем его в бизнес (диспатчим санку)

Илья Иваник
2 года назад
Такие кнопки очень легко стилизовать:

<!-- ...
const ref_input = useRef(null)
...
<div onClick={() => ref_input.current.click()}>загрузить фото</div>
<input onChange={upload} ref={ref_input} style={{display: 'none'}} type='file'/> -->

97. - ReactJS - обновление

Обновление профиля. Опять redux-form, не забываем со старта закинуть в эту форму initialValue из нашего бизнес-стейта.

Дальше заполняем\меняем форму и сабмитим её. В санке отправляем полный объект на сервак и если в ответе resultCode = 0, то всё ок! Можно запросить заново стейт, чтобы получить с сервака обновлённый стейт (хотя можно было и без запроса просто обновить стейт тем, что пришло в санку).Обновление профиля. Опять redux-form, не забываем со старта закинуть в эту форму initialValue из нашего бизнес-стейта.

Дальше заполняем\меняем форму и сабмитим её. В санке отправляем полный объект на сервак и если в ответе resultCode = 0, то всё ок! Можно запросить заново стейт, чтобы получить с сервака обновлённый стейт (хотя можно было и без запроса просто обновить стейт тем, что пришло в санку).

Коментарий:

Чтобы проитерировать через объект как крутой чувак 10001% можно заюзать Object.entries. В этом коде я юзаю react-hook-form (там нужно каждый инпут регистрировать, и для регистрации нам и понадобится "ключ")

  <!-- const contactList = Object.entries(profile.contacts).map(function(contact) {
    let key = contact[0];
    let value = contact[1];
    return (
      <div id="contact" key={key}>
      {(!editMode && value!=="") && <label htmlFor={key}>
        {key.charAt(0).toUpperCase() + key.slice(1)}: 
      </label>}
      {editMode ? (
        <>
          <label htmlFor={key}>{key.charAt(0).toUpperCase()+key.slice(1)}: </label>
          <input {...register(key)} id={key} defaultValue={value} type="text" />
        </>
      ) : (
        <span>
          <a href={value}>{value}</a>
        </span>
      )}
    </div>
    )
  }) -->

key.charAt(0).toUpperCase() + key.slice(1) здесь чисто для форматирования (ключ всегда будет начинаться с большой буквы)
Object.entries возвращает большой массив который выглядит типа как
[
['github', 'github/1'], ['vk', 'vk/2'], ['linkedin', 'linkedin/3']
]
Потом мы применяем метод map и пропихиваем в него функцию, в которой contact является ВНУТРЕННИМ массивом в общем массиве. эта функция деструктурирует каждый ВНУТРЕННИЙ массив на два элемента (key и value, потому что именно этим и являются два элемента в каждом внутреннем массиве)
И соответственно за каждый внутренний массив мы возвращаем <div></div>

98. - ReactJS - captcha

setErorr - ставится в конце всех аргументов.

99. - ReactJS - try-catch, router switch, classnames

Кстати по поводу react-router-dom Можно ещё сделать так {/_<Route exact path={['/login', '/register']} component={Auth} />_/}, несколько роутов на один компонент, может кому пригодится.

Farragut West
Farragut West
3 года назад
Вспоминаем пройденное.

вставки типа %PUBLIC_URL% в index.html файле webpack заменяет на настоящие пути
SerwiceWorker - это из темы Progressive Web Application (PWA)
ReactNative - react код компилируется в Java код, или Objective C код
<Switch><Route .../> <Route .../> <Route .../> </Switch> - switch case для роутов, можно использовать вместо exact, страбатывает только полное совпадение роута как в .NET ных роутах
В <Switch> можно положить роут по умолчанию path = ' \* '
В <Switch> важен порядок, поиск идет до превого совпадения
В <Switch> так же можно использовать exact

reacttraining.com/react-router/web/api/Route

HTTP протокол по умолчанию НЕ case sensetive

cn:

<div className=(cn{s.MyName1, s.MyName1, s.MyName1}) /> - способ назначить несколько классов не используя конкатенацию строк, а просто через запятую

<div cn( {[s.MyName] : currPage === apples} ) /> -  способ включать или выключать калссы в зависимости от условной логики, имя класса берется в [ ] поотму что строка

github.com/JedWatson/classnames - cn документация

если мы забыли обработать promise который зареджектился (reject) то мы можем в одном месте обработать все такие промисы
window.addEventListener("unhandledrejection", () => { ... })

componentWillUnmont() - функия жизненного цикла в которой хорошо отпысываться от событий, (таких как addEventListener)

Максим Сахаров
10 месяцев назад (изменено)
самурай Вот РАБОЧЕЕ РЕШЕНИЕ НА ИЮНЬ 2022 – нужно установить последнюю версию - react-router-dom (если у вас не шестая версия) и потом сделать импорт Navigate c react-router-dom и потом так прописать
<Route path="/" element={<Navigate to="/profile" />} />
И
<Route path='\*' element={<NotFound />} />

G P
4 месяца назад
Switch отменили
Вместо компонента Switch теперь появился компонент Routes. Но это не просто переименование — Routes более функционален. Основное отличие в том, что Routes не требует жесткого порядка роутов внутри.
Switch обходил роуты в строгом порядке сверху вниз и при первом совпадении пути рендерил заданный компонент. Поэтому важно было определить порядок: например, выносить вниз наиболее общий роут
Компонент Switch «более умный» и сматчит наиболее подходящий роут:

100. - Теория ReactJS + Redux за 90 минут - кратко обо всем

-----------------------------------------------------Путь Самурая 2.0--------------------------------------------------------------------- 01) - Введение, TypeScript, Apollo, AntDesign, WebSocket / React JS

В новом сезоне нас ждёт:

- строгая типизация в связке React + TypeScript
- красивый внешний вид (CSS фреймворк\библиотека Ant Design)
- реактивное двустороннее взаимодействие с сервером с помощью WebSocket (socket.io)
- альтернативное Rest API взаимодействие с сервером с помощью языка GraphQL
- альтернативный Redux стейт менеджмент с помощью Apollo, играющего по правилам GraphQL

02.  - React-у жизненно необходим TypeScript / React JS - Путь Самурая 2.0

В данном уроке я постараюсь доказать вам, что TypeScript нам ЖИЗНЕННО необходим!

Не создавался JS как язык для написания больших систем! А сегодня мы пишем большие системы. И JS-у нужна помощь!

TypeScript - это почти JS, только более навороченный. Фактическ да, TypeScript - это другой язык программирования. Программа, написанная на TS компилируется\транспилируется в программу, написанную на JS. Подобными вещами занимается Babel.

Давайте вспомним JSX - тоже ведь фактически это новый язык, который превращается Бабелем в JavaScript! И нам нужен JSX, с ним удобнее! Точно так же удобнее и проще писать более устойчивое к багам App с помощью TypeScript.

03.  - React + TypeScript за 30 минут/ React JS - Путь Самурая 2.0

В данном выпуске, котоырй получился слегка скомканным, я примерно рассказал о том, что нам нужно понимать в TypeScript, чтобы радоваться всему, что происходит в React+Redux! В будущих выпусках мы типизируем все reducer-ы, api, connect, компоненты, redux-form, хуки!

Max Kos
2 года назад
При использовании TypeScript ошибки типов в runtime будут выпадать или в процессе компиляции (когда Babel транспилит TypeScript в примитивный код)?

IT-KAMASUTRA

Ответить

IT-KAMASUTRA
·

2 ответа
IT-KAMASUTRA
IT-KAMASUTRA
2 года назад
Никакого рантайма! На этапе компиляции

04. - Redux + TypeScript / React JS - Путь Самурая 2.0


 У кого не получается стартануть после апгрейда cra - добавьте tsconfig.json в корневую директорию (достаточно, вроде, вставить базовый из интернета), потом пару раз перезапустите проект. Подсказал человек в нижних камментах, ему спасибо!

на 4:25 - tsconfig.json у меня не добавился в текущий проект автоматом и соответственно была такая ошибка «File is not included in any tsconfig.json» – я скопировал его с пустого чистого проекта и вставил в наш существующий и все стало ок) – ошибки стало как у Димыча показывать.

Лайфхак: горячей клавишей Alt+Shift+Enter, можно импортировать все, что нужно файлу


@86desen
2 года назад (изменено)
Кто словил ошибку при старте:
"node_modules/react-scripts/scripts/utils/verifyTypeScriptSetup.js:239
      appTsConfig.compilerOptions[option] = value;"
Мне помогло данное решение: https://github.com/facebook/create-react-app/issues/9868#issuecomment-715418383, путь к скрипту указан в ошибке.

05. - React + connect, TypeScript, mapStateToProps, mapDispatchToProps / React JS - Путь Самурая 2.0

@alexanderemelyanov729
2 года назад
Ловил ошибку classnames не найден, тайпскрипт classnames не найдет, несколько раз через yarn и npm скачивал classnames и @types/classnames, скачивал все модули. Но всё равно classnames не работали. Пока не заметил что при установки @types/classnames в package.json в dependencies удалялся обычный модуль  classnames. Всё заработало после того как вручную добавил в dependencies  "classnames" : "2,2,6". npm install @types/classnames --save


@elena_sarkisova
3 года назад
Спасибо большое за урок.  У меня к Вам два вопроса: 
1) Почему,  когда устанавливаете пакеты yarn'ом, не указываете параметры  (--save,  --dev).  Я заметила,  что автоматом не сохраняется в package.json. Ну и тем более,  если ставить пакеты @types/... (они же должны пойти в dev,   я правильно понимаю?) 
2) Как все-таки правильнее,  типизировать принудительно переменные,  которые типизируются автоматически при первом присваивании и typescript на них не ругается, или пропускать (тк будет что-то вроде дублирования)? Я не говорю о тех случаях,  когда переменная реально в дальнейшем может стать,  например,  null.


Ответить

yarn по умолчанию ставит пакет с savе флагом
Интересные моменты:


6. - React + Redux + TypeScript, типизация Actions и Thunk / React JS - Путь Самурая 2.0


Redux-saga — это альтернативный подход к организации сайд-эффектов. Вместо того, чтобы диспатчить функции, которые обрабатываются redux-thunk-ом, вы создаёте сагу, которая собирает всю логику обработки внутрь себя. В отличие от thunk-ов, которые выполняются, когда вы их диспатчите, саги запускаются при старте приложения и как бы «работают в фоне». Саги слушают все экшены, которые диспатчит стор, и решают, что делать с ними.

И у саг в редаксе два преимущества по сравнению с thunk-ами:
— Они позволяют организовывать сложные последовательности сайд-эффектов
— И они очень легко тестируются


@alexdeadlenin9255
3 года назад
Отличные уроки. Спасибо за труд! 
Нашел отличную статью как автоматизировать сборку ActionTypes
https://habr.com/ru/company/alfa/blog/452620/

7. - React + Redux + TypeScript, типизация axios, api, enum, Promise / React JS - Путь Самурая 2.0


@vladbalabkin4661
2 года назад
в follow, unfollow может вернуться 2 разных объекта, если ошибка, то возвращается вот такая фигня: {message: 'error'}

type ErrorMessageObjectType = {
  message: string
}

type FollowUnfollowType =
  | {
      data: {}
      fieldsErrors: string[]
      messages: string[]
      resultCode: ResultCodesEnum
    }
  | ErrorMessageObjectType

и в user-reducer надо это как-то обработать и я не могу понять, как мне понять, какого типа приходит объект
typeof res === typeof ErrorMessageObjectType, typeof res === ErrorMessageObjectType - не работает
нарыл в гугле вот такую фигню

interface ErrorMessageObjectType {
  interfaceID: "ErrorMessageObjectType"
  message: string
}

export function isInstanceOfErrorMessageObjectType( object: any ): object is ErrorMessageObjectType {
  return object.interfaceID === "ErrorMessageObjectType"
}

и вот так типа чекать: 
if (isInstanceOfErrorMessageObjectType(res)) {
  dispatch(displayError(res.data.message))
} else {
  // code....
}

но у меня даже так подчёркивает, что message в data нет

8. - Redux-Form + TypeScript + Generic или как решать проблемы / React JS - Путь Самурая 2.0


10. - React + TypeScript / Типизируем ВСЁ / React JS - Путь Самурая 2.0

@user-np9mq5xc7j
1 год назад
что бы вынести в VSCode что то в отдельный файл нужно это выделить, нажать правой кнопкой -->Рефакторинг...new file

@dimzinnatov7242
2 года назад
Я пользуюсь свагером для автогенерации api, вроде как все удобно сделано) но может у тебя есть еще что-то на примете, более функциональнее или удобнее, то прошу сказать об этом))


(01.) TypeScript / Generic and Conditional Type / as const / infer


@user-lq5fs9eb8v
3 года назад (изменено)
Там ксати в той статье по ссылке, в одном из комментариев есть ссылка на библиотеку Unionize. Не пробовал еще, бегло глянул. выглядит интересно для объединения экшенов

@alexdeadlenin9255
3 года назад
что бы не писать везде " import ... as ... from '...' " можно в tsconfig прописать
 "esModuleInterop": true,
 "allowSyntheticDefaultImports": true
по дефолту черезе  npx create-react-app my-app --template typescript оно и так стоит, но в уже существующем, рабочем проекте, пригодиться может

@ArtikMan1994
2 года назад
inter U очень напоминает typeof. Он ведь так же выводит типы обьекта автоматически. В чем тогда разница? Спасибо
@ITKAMASUTRA
2 года назад
По смыслу да, похожи, просто в разных сценариях юзаются разные операторы! Там где нужно не просто определить из конкретики, а догадаться из generic, там infer

11. - React + TypeScript / Типизируем ВСЁ / React JS - Путь Самурая 2.0

(02) TypeScript / Omit / HOC



@Karifax
3 месяца назад
решил проблему в withAuthRedirect таким образом

___________________________________________________________________________________________________________________________
Делали фуллстек - бэк на express (кроме джаваскрипта ж ничё не знаем), бд - mongo, для отображения верстки - handlebars. Деплоил сам на digitalocean, как прокси-сервер использовал nginx.
Дублирование кода - для программиста самый страшный грех!!!

Интересные вопросы:

Баги и фичи

1 подписка-отписка происходит только после обновления страници в браузере;
2 пагинация возвращается к первой странице после обновления страници в браузере;
3 при переходе на страницу профиля, работает постоянный Лоудер, возможно надо добавить (захардкодить) профиль по умолчанию (+);
4 при добавлении ХОКа логина при обновления страници в браузере переходит на страницу логина.
5 Доделать 75-77 уроки вместо redux form на react hook form c переходом типа ввода пароля с пассворда на текст (+).
6 Блокировка editMode редактирования статуса пользователя с id отличающегося от id собственника страницы
7 Нет понимания как сделать уникальный id меняющихся соообщений, пользователя ... (как это взять из react hook form)
8 Сделать функцию по Inputu, для того что бы убрать дублирование.

https://mariosfakiolas.com/blog/my-react-components-render-twice-and-drive-me-crazy/

Интервью

Miteki group
погодинна middle позиція на короткий проект react на 4 тижні
14 доларів\година

1Типи данних в джава скріпті
2 Функція стрілка vs function diclaration
3 Що таке методи функцій (call apply bind)
3 Rest vs graphql
4 Архітектура реакт аплікух, як вибрати архітектуру
5 Як зробити авторизацію на фронті
6 Var let const. Hoisting
7 Блочні і строкові теги (чому не можна всередині строчних писати блочні)
8 Які існують хуки, для чого useReducer
9 Як працює редакс, які проблеми вирішують стейт менеджери.
10 В чому різниця між display none і visibility hidden
11 Як визначити коли краще використоувати mui? а коли taiwind css?
12 Проміси, багатопоточність vs асинхронність
13 Strict mode в react vs strict mode in JavaScript
